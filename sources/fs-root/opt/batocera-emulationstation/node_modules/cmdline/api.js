/**
 * @file
 * This file contains a generic utility to define command line actions + arguments for them,
 * as well as the parser to map the input array into a more convenient structure.  
 * It is also capable of some basic verifications to make sure required arguments were and - optionally -
 * that they are of a certain type.  
 * The idea of this utility was to separate handling the logic of argument parsing and validation from their definition 
 * to keep the command definitions as short and concise as possible.
 * But it should also allow extended configuration when needed (rarely).
 * 
 * Basic flow:
 * 1. Define the action with `action(optionSpec, handler)`.  
 *    This will return a function mapping `handler` which takes care of the pre-processing.
 * 2. Call the mapper function with a raw array of arguments as coming from `process.argv`.
 * 3. The mapper uses `processOptionConfig(optionSpec)` to evaluate which options and arguments are expected.  
 *    This yields an instance of [OptionConfig].
 * 4. The instance of `OptionConfig` will be passed to `parseCmdLine(config, argv)` to apply the configuration against the
 *    the actually passed console arguments. The resulting [ParsedOptionDict] and the list of transformed/filtered positional 
 *    arguments are passed to the `handler` function. 
 * 
 * @see processOptionConfig
 * @see parseCmdLine
 */

const fs = require('node:fs');
const io = require('logger').get();

/**
 * Any handler passed to `api.action(optionSpec, handler)` receives an instance of this class as first argument.  
 * It's mostly just a simple object, with a few convenience helpers for easier processing.
 *   
 * The keys used correspond to those of all named (=none-integer) options contained in `optionSpec`, 
 * but the values are converted according the the validators used (if any).
 * 
 * @example
 *   Input: api.action({ '--flag': 0 }, ...)
 *  Output: { '--flag' : true|false }
 */
class ParsedOptionDict {
  hasMatchingOptions(expression) {
    let exp = new RegExp(expression);
    return Object.keys(this).findIndex(_ => exp.test(_)) >= 0;
  }
}

/**
 * This is the main return value of `parseCmdLine()`.  
 * It is used internally in `api.action()` as intermediate class to transport the results of command line parsing.  
 * Handler functions will get the contents of `ParsedCmdLine.options` as first argument and the entries of `ParsedCmdLine.arguments`
 * unpacked into separate varArgs.
 *
 * - `options` is [ParsedOptionDict]
 * - `arguments` is a mixed-type arry
 */
class ParsedCmdLine {
  constructor() {
    this.options = new ParsedOptionDict();
    this.arguments = [];
  }
  setOptionValue(opt, val) { this.options[opt] = val }
  addArgument(arg) { this.arguments.push(arg) }
  numArgs() { return this.arguments.length }
}

/**
 * This function uses the preprocessed `[OptionConfig]` to parse and transform the actual command line.  
 * Argument values are transformed according to the Validators specified in the initial `optionSpec`.
 * 
 * @see processOptionConfig
 * @see VALIDATORS
 * @return {ParsedCmdLine}
 */
function parseCmdLine(options, ...args) {
  let errors = [];
  let context = new ParsedCmdLine();
  //positive matching in given command line
  for (let i = 0; i < args.length; i++) {
    let value = args[i];
    let config = options.getConfig(value);
    //current value is not an option, but positional
    //check if there is a validator for this (next) position (1-starting index)
    if (config === false) { config = options.getConfig(context.numArgs() + 1) }

    if (config === false) {
      context.addArgument(value);
      continue
    }

    let validationStart = (config.isPositional()) ? i : i + 1;
    let restArgs = args.slice(validationStart);

    let validationResult = config.validator.call(context, ...restArgs);
    if (!validationResult.success) {
      if (config.isSkippablePositional()) {
        validationResult.value = false;
        // consumedArgs 0 in positionals will lead to the same argument being eval'd again
        // because i will effectively be reduced with -1 in the last line of the loop iteration
        validationResult.argsConsumed = 0;
      } else {
        errors.push(value + ': ' + validationResult.value);
        continue;
      }
    }

    //either take value as given by validator
    // or pick #argsConsumed arguments from lookahead arguments array
    let pickedArgs = typeof validationResult.value != "undefined" ? validationResult.value
      : restArgs.splice(0, validationResult.argsConsumed);

    if (config.isPositional()) { context.addArgument(pickedArgs) }
    else { context.setOptionValue(value, pickedArgs) }
    //skip over consumed args
    i += (validationStart - i + validationResult.argsConsumed - 1);
  }

  for (let [name, conf] of Object.entries(options)) {
    //positionals will be checked once at the end
    if (conf.isPositional()) { continue }
    if (typeof context.options[name] != "undefined") { continue }

    if (conf.required) { errors.push(`${name}: parameter is required`) }
    //FIXME: setting all optionals to false does not work for parameters requiring values?
    //else { context.setOptionValue(name, false) }
  }

  let positionalValidation = options['#POS'].validator(...context.arguments);
  if (!positionalValidation.success) { errors.push(positionalValidation.value) }

  if (errors.length > 0) { throw errors.join('\n') }
  return context;
}

class OptionConfig {
  getConfig(rawArgValue) {
    let propName = OptionConfig.cleanName(rawArgValue);
    return this[propName] || false;
  }
  getOptions() { return this.#filter(_ => !_.isPositional()) }
  getPositionals() { return this.#filter(_ => _.isPositional()) }
  getRequired() { return this.#filter(_ => _.isRequired()) }

  #filter(criteria) {
    let result = {};
    for (let [name, option] of Object.entries(this)) {
      if (criteria(option)) { result[name] = option }
    }
    return result;
  }
  static cleanName(rawArgValue) {
    if (String(rawArgValue).startsWith('*')) { rawArgValue = rawArgValue.replace('*', '') }

    let asNumber = parseInt(rawArgValue);
    if (asNumber >= 0 && String(asNumber) == rawArgValue) { rawArgValue = asNumber }

    return rawArgValue;
  }
}

class ConfigEntry {
  constructor(cfgName, isRequired, validatorFun) {
    this.name = cfgName;
    this.required = isRequired;
    this.validator = validatorFun;
  }

  isPositional() { return this.name == '#POS' || Number.isInteger(this.name) }
  isSkippablePositional() {
    return !this.required && this.isPositional()
      && this.validator.positionalSkippable();
  }

  isRequired() {
    if (this.isPositional()) { return !this.isSkippablePositional() }
    else { return this.required }
  }

  optDesc() {
    let description = this.validator.call(VALIDATORS);
    if (!this.isPositional()) { description = this.name + ' ' + description }
    if (!this.isRequired()) { description = '[' + description.trim() + ']' }
    return description;
  }
}

class ValidatorResult {
  constructor(successful, numArgs, adjustedValue) {
    this.success = successful;
    this.argsConsumed = numArgs;
    this.value = adjustedValue;
  }

  static forSimpleResult(rawSimpleValidatorResult) {
    if (rawSimpleValidatorResult instanceof ValidatorResult) { return rawSimpleValidatorResult }

    let success = true;
    let argsConsumed = 1;
    let transformedValue;

    switch (typeof rawSimpleValidatorResult) {
      case "string":
        success = false;
        transformedValue = rawSimpleValidatorResult;
        break;
      case "boolean":
        if (rawSimpleValidatorResult === false) {
          success = false
        }
        break;
      case "number":
        success = true;
        argsConsumed = rawSimpleValidatorResult;
        break;
      case 'object':
        success = true;
        transformedValue = rawSimpleValidatorResult;
        break;
      case 'undefined':
      default:
        success = false;
        transformedValue = 'validator function returned no valid result';
        break;
    }
    return new ValidatorResult(success, argsConsumed, transformedValue);
  }

  static of(success, consumedArgs, value) { return new ValidatorResult(success, consumedArgs, value) }
}

/**
 * @section VALIDATORS
 * This is a dictionary containing all known command line argument validators. These validators serve 2 purposes:
 * - They check if a given argument value matches a specific criteria
 * - (Optionally) Convert the raw argument to another type of structure, depending on the concrete validator
 * 
 * How to use:  
 * - All inbuild validators can be used by specifying a certain value for an argument in `optionSpec`.
 * - But there is also the option of importing and directly assigning them. This only works for simple validators that
 *   do not require additional configuration
 * - The validator names can also be used. But this does also not work with validators requiring more arguments.
 * - Full rules explaining how `optionSpec` works in the section `[processOptionConfig]`
 * 
 * But for most use cases, there is no need to use, touch or look at this dictionary.
 * 
 * Internally, validators can run in 2 different 'modes'.
 * 1. 'Name' mode - The validator does not perform any action, but returns a string representation of its expectation/format.  
 *    This is used in case of errors and when `btc-config --help` is used to print commands and their arguments.
 * 2. 'Validation' mode - Regular operation when command line arguments are evaluated.
 * 
 * The object `VALIDATORS` itself is a {Proxy} with an implementation of `get()` which returns bound functions. 
 * That way, argument configuration is attached to validators and the bound/pre-configured validators are used
 * when parsing the command line.  
 */
const VALIDATORS = new Proxy({
  /**
   * Check that the given number of arguments is still available to be parsed.  
   * Configuration for `optionSpec` to use this is:
   * 
   * ```js
   * //simple variant - one argument
   * action({ optionName: # }, (options) => {})
   * //complex variant, allows to pass custom name prefix for the help function in addition to number of args
   * { optionName: { argsRemaining: #, (#offset), string|function} }
   * ```
   * 
   * - `#` must be an integer number >= 0.  
   * - `#offset` defines where to start numbering arguments in the generated help.  
   * 0 for `#` itself only works for string-named options, not for positional arguments. Such options will be considered as
   * boolean true/false flags.
   */
  argsRemaining: function(numArgs, addConfig, ...argArray) {
    if (this == VALIDATORS) {
      let namePrefix = 'arg';

      addConfig ||= [0];
      if (addConfig.length == 1 && typeof addConfig[0] != "number") { addConfig.unshift(0) }

      let offset = addConfig[0] || 0;
      let nameGenerator = addConfig[1] || namePrefix;
      if (typeof nameGenerator != "function") {
        namePrefix = nameGenerator;
        nameGenerator = (idx, offset) => {
          if (idx < 0 || offset < 0) { return namePrefix }
          else { return namePrefix + (idx + offset) }
        }
      }
      if (numArgs == 1 && offset == 0) { return nameGenerator(-1, -1) }
      else if (numArgs > 1 && offset == 0) { offset = 1 }
      return [...Array(numArgs)].map((v, i) => nameGenerator(i, offset)).join(' ')
    }

    // For flag-type options. Validator being called means the flag is in the arg array
    // numArgs 0 means: do not bind any more following args as value to the option
    // This is pointless for positional checks as it would mean:
    // positional with number 'name' must be there, but its value is ignored
    // and not added to positionalArgs. Instead 'true' is added
    if (numArgs == 0) { return ValidatorResult.of(true, 0, true) }

    if (typeof addConfig != 'undefined' && !Array.isArray(addConfig)) { argArray.unshift(addConfig) }

    if (argArray.length >= numArgs) {
      let result = argArray.slice(0, numArgs);
      if (numArgs == 1 && result.length == 1) { result = result.shift() }
      return ValidatorResult.of(true, numArgs, result);
    }
    return ValidatorResult.forSimpleResult(`requires ${numArgs} arguments`);
  },
  includesFirst: function(includesArray, unused, firstArg = '') {
    //#SKIPPABLE
    if (this == VALIDATORS) { return includesArray.join('|') }

    if (!includesArray.includes(firstArg)) {
      return ValidatorResult.forSimpleResult(`must be one of [${includesArray.join('|')}]`);
    } else {
      return ValidatorResult.of(true, 1, firstArg);
    }
  },
  regExp: function(expression, unused, firstArg = '') {
    //#SKIPPABLE
    if (this == VALIDATORS) { return '=' + String(expression) }

    return ValidatorResult.forSimpleResult(
      expression.exec(firstArg)
      || `<${firstArg}> must match ${expression}`);
  },
  commaList: function(noconf, unused, firstArg = '') {
    if (this == VALIDATORS) { return 'arg1[,arg2]...' }

    return ValidatorResult.forSimpleResult(
      firstArg.trim().length == 0
        ? `csv-value expected - <${firstArg}> must contain at least one none-whitespace character`
        : String(firstArg).split(',')
    );
  },
  varArgs: function(pickArgumentCondition, unused, ...argArray) {
    let prefix = 'conditional';
    if (this == VALIDATORS) { return `<${prefix ? prefix + ':' : ''}[arg1] [arg2] [...]>` }

    if (typeof pickArgumentCondition != "function") {
      return ValidatorResult.of(false, 0, '[coding error] varArgs validation requires an iterative test function during definition')
    }
    let firstNonIncluded = argArray.findIndex((e, i, a) => {
      return !pickArgumentCondition(e, i, a);
    });
    let resultingArray = firstNonIncluded < 0 ? argArray : argArray.slice(0, firstNonIncluded);
    return ValidatorResult.of(true, resultingArray.length, resultingArray);
  },
  file: function(noconf, unused, firstArg = '') {
    //#SKIPPABLE
    if (this == VALIDATORS) { return 'existing/file/path' }

    if (!fs.existsSync(firstArg)) { return ValidatorResult.of(false, 0, `<${firstArg}> does not exist`); }
    let stat = fs.statSync(firstArg);
    if (stat.isFile()) { return ValidatorResult.of(true, 1, firstArg); }
    return ValidatorResult.of(false, 1, `<${firstArg}> is not a regular file`);
  },
  customFunction: function(customValidator, unused, ...argArray) {
    if (this == VALIDATORS) {
      if (typeof VALIDATORS[customValidator.name] == "function") { return customValidator.call(this) }
      else { return '<function arguments>' }
    }
    return ValidatorResult.forSimpleResult(customValidator.call(this, ...argArray));
  }
}, {
  get(target, prop, receiver) { return _pseudoBind.bind(null, prop, target[prop]) }
});

/**
 * @endsection
 */

/**
 * Bind does not allow to change this, but the resulting validator must be able to receive another this.
 */
function _pseudoBind(valName, validator, ...rest) {
    //the wrapper is used to get JS to build a proper name for the dynamically created function
    let valArgs = [];
    switch(rest.length){
      case 2:
        valArgs.push(rest[0]);
        let last = rest[1];
        if (!Array.isArray(last)) { last = [last] }
        valArgs.push(last);
        break;
      case 1: 
        valArgs.push(rest[0], []);
        break;
      case 0:
        valArgs.push(null, []);
        break;
      default:
        varArgs.push(rest[0], rest.slice(1));
        break;
    }
  let valWrapper = {
    [valName]: function(...validationArgs) { return validator.call(this, ...valArgs, ...validationArgs) }
  }
  let unpacked = valWrapper[valName];
  if (valName == "customFunction") { unpacked.toString = function() { return rest[0].toString() } }
  else { unpacked.toString = function() { return validator.toString() } }
  unpacked.positionalSkippable = function() {
    return (unpacked.toString().split('\n')[1] || '').trim() == "//#SKIPPABLE"
  }
  return unpacked;
}

/**
 * This function unpacks and inteprets the `optionSpec` given to [`action`]. It receives the first argument passed
 * to [`action`] and expects this to be a dictionary with a certain format.
 * 
 * ```js
 * {
 *   <optionName> : validatorConfig|validatorName|typeSpec,
 *   <#posInt>: validatorConfig|validatorName|typeSpec
 *   #POS: int
 * }
 * ```
 * **Rules for keys:**
 * - `<optionName>`: any literal string, none-number string.  
 *   '-' or '--' must be part of the string if desired. This is used for named options.
 * - `<#posInt>`: Numbers, or strings parsing as numbers. These are positional arguments, starting with 1.
 * - #POS: special type. Allows to enforce a minimum number of positional arguments.
 * - Any `<optionName>` or `<#posInt>` can be prefixed with '*' to mark the given argument as required.  
 *   When such an argument is not given, or the configured validation fails, the action aborts with an error.
 * 
 * **Values:**
 * - {number} > 0: [argsRemaining] with given number of arguments
 * - 0: [argsRemaining] - for string-named options: true|false flags
 * - {RegEx}: [regExp] - argument given at position or as value must match expression
 * - 'file': [file] - argument given at position or as value must be an existing file
 * - 'csv': [commaList] - argument at position or as value will be interpreted as csv.  
 *   Must have at least one entry (must not be empty)
 * - {Array}: [includesFirst] - Useful for enum-like string argument lists.  
 *   Argument on command line must be a string matching one entry of the array.
 * - {validatorName: validatorConfig} - Provides a way to pass extended validator configuration.  
 *   Only applicable to [argsRemaining] for now, or - more generically - to validators taking more then one  
 *   argument in "factory mode".
 */
function processOptionConfig(rawOptions) {
  let processed = new OptionConfig();
  let requiredPositional = rawOptions['#POS'] || 0;
  let highestPositional = requiredPositional;

  for (let [optionName, setting] of Object.entries(rawOptions)) {
    io.debug("process raw option", optionName, JSON.stringify(setting))
    if (optionName == '#POS') { continue }
    let isRequired = optionName.startsWith('*');
    optionName = OptionConfig.cleanName(optionName);
    let isPositional = Number.isInteger(optionName);

    let help = [];
    if (isPositional) {
      if (optionName < 1) { throw "First positional must have number 1" }
      highestPositional = Math.max(highestPositional, optionName);
      isRequired = isRequired || (optionName <= requiredPositional);
      if (isRequired) {
        requiredPositional = Math.max(requiredPositional, optionName);
      }
    } else {
      help.push(optionName);
    }

    let validator;
    let configType = Array.isArray(setting) ? 'array' : typeof setting;
    switch (configType) {
      case 'number':
        validator = VALIDATORS.argsRemaining(setting);
        break
      case 'array':
        validator = VALIDATORS.includesFirst(setting);
        break
      case 'string':
        if (setting == 'csv') {
          validator = VALIDATORS.commaList();
          break
        } else if (setting == 'file') {
          validator = VALIDATORS.file();
          break;
        }
        setting = new RegExp(setting);
      case 'object':
        if (setting instanceof RegExp) {
          validator = VALIDATORS.regExp(setting);
        } else if (setting instanceof String) {
          validator = VALIDATORS.argsRemaining(1, setting.valueOf());
        } else if (Object.keys(setting).length == 1) {
          let [val, conf] = Object.entries(setting)[0];
          if (!Array.isArray(conf)) { conf = [conf] }
          else { conf = [...conf] } //must not manipulate the raw option entry because it must be re-usable
          validator = VALIDATORS[val](conf.shift(), conf);
        }
        break
      case 'function':
        if (setting == File) {
          validator = VALIDATORS.file();
          break;
        }

        if (typeof VALIDATORS[setting.name] == "function") { validator = setting }
        else { validator = VALIDATORS.customFunction(setting) }
        break
    }

    if (typeof validator == "undefined") {
      throw `Unsupported option configuration: ${optionName}:{${configType}} ${JSON.stringify(setting)}`;
    }

    processed[optionName] = new ConfigEntry(optionName, isRequired, validator);
  }
  processed['#POS'] = Object.assign(new ConfigEntry('#POS', requiredPositional > 0,
    VALIDATORS.argsRemaining(requiredPositional)), {
    amount: requiredPositional,
    optDesc: false
  })
  for (let i = 1; i <= Math.max(requiredPositional, highestPositional); i++) {
    let posCfg = processed.getConfig(i) || new ConfigEntry(i, false, VALIDATORS.argsRemaining(1, [i, 'posArg']))
    posCfg.required = i <= requiredPositional;
    posCfg.required = !posCfg.isSkippablePositional()
    processed[i] = posCfg;
  }

  return processed;
}

function renderActionHelp(cmdName, optionConfig = {}, brief = '', detailMode = false, details = '') {
  let options = processOptionConfig(optionConfig);
  let output = brief;
  let argSpecProvider = (o => o.optDesc());
  let detailString = details;

  if (typeof details == 'object') {
    if (typeof details.argSpec == 'function') { argSpecProvider = (o) => details.argSpec(o) || o.optDesc() }
    output = output || details.brief || '';
    detailString = details.fullSpec || '';
  }

  if (Array.isArray(detailString)) { detailString = detailString.join('\n') }

  let optionSpec = Object.values(options.getOptions()).filter(o => detailMode || o.isRequired()).map(argSpecProvider).join(' ');
  let positionalSpec = Object.values(options.getPositionals()).filter(_ => typeof _.optDesc == "function").map(argSpecProvider).join(' ');

  if (detailMode) {
    output = [
      `\n*** ${cmdName} ***`,
      ...(output.length > 0 ? [output] : []),
      '\nUsage:',
      `  * btc-config ${cmdName}${optionSpec ? ' ' + optionSpec : ''}${positionalSpec ? ' ' + positionalSpec : ''}`,
      ...(detailString && output ? [''] : []),
      ...(detailString.length > 0 ? [detailString] : []),
      ...(detailString || output ? [''] : []),
      '---'
    ].join('\n');
  } else {
    if (output) { output = output.split('\n').join('\n    ') }
    output = `\n  * ${cmdName}${optionSpec ? ' ' + optionSpec : ''}${positionalSpec ? ' ' + positionalSpec : ''}${output ? `\n  : ${output}` : ''}`;
  }
  io.userOnly(output);
}

function action(options, realFunction, documentation = '') {
  // options is a supplier function for lazy init
  if (typeof options == 'function') { options = options() }

  let optionDeclaration = options;
  if (process.env.BTC_VERIFY_API) {
    processOptionConfig(optionDeclaration);
  }
  function realCallWrapper() {
    try {
      let innerOptions = processOptionConfig(optionDeclaration);
      let cmdLine = parseCmdLine(innerOptions, ...arguments);
      io.debug(`OPTIONS:`, cmdLine.options);
      io.debug(`ARGUMENTS:`, cmdLine.arguments);
      return realFunction(cmdLine.options, ...cmdLine.arguments);
    } catch (e) {
      io.error('error while trying to parse or run command line')
      io.error(e.stack || e);
      throw e;
    }
  }
  realCallWrapper.description = function(cmdName, detailMode = false, details = '') {
    renderActionHelp(cmdName, optionDeclaration, documentation, detailMode, details)
  }
  return realCallWrapper;
}

class ApiOutput { }

class JsonOutput extends ApiOutput {
  constructor(data = {}) {
    super();
    this.data = data
  }
  toString() { return JSON.stringify(this.data, null, 2) }
}

class StringOutput extends ApiOutput {
  constructor(data = '', arrDelim = '\n') {
    super();
    this.data = data;
    this.delim = arrDelim;
  }
  toString() {
    return Array.isArray(this.data)
      ? this.data.join(this.delim)
      : `${this.data}`;
  }
}

module.exports = {
  action,
  ValidatorResult, VALIDATORS,
  ApiOutput, JsonOutput, StringOutput
}
