#!/usr/bin/node

const fs = require('node:fs');
const resolve = require('node:path').resolve;
const log = require('./config.libs/logger.js').get();

const api = require('./config.libs/cmdline-api.js');
const data = require('./config.libs/data-utils.js');

Object.assign(globalThis, require('./config.libs/path-utils.js'));
globalThis.API = {};

globalThis.FS_ROOT = envOrVarAbsPath('FS_ROOT', __dirname + '/../..');

API['controller:applyGuide'] = api.action(
  {
    //for profile merging 
    '*1': 'file', '--name': 1, '--target-file': { 'argsRemaining': [1, 'file'] },
    //when given, svg files will also be generated for the merged result
    //advantages: 
    // - avoids redundant reparsing of the xml file
    // - and the cost associated with calling 'btc-config'
    '--svg': 0, '--svg-target-dir': 1, '--svg-name-prefix': 1
  },
  (options, baseProfileName) => {
    let apply = require('./config.libs/controllers.js').applyGuideProfile;
    let mergedProfile = apply(baseProfileName, options['--name'] || false)

    let xmlTargetFile = options['--target-file'] || process.stdout;

    let xmlWriter = require('./config.libs/output-formats.js').xml;
    xmlWriter.write(mergedProfile, xmlTargetFile, {
      comment: `Generated by 'btc-config applyGuideProfile' from [${baseProfileName}]`
    });

    if (options.hasMatchingOptions('--svg.*')) {
      let createSvgs = require('./config.libs/controllers.js').profileToImage;
      //directly pass the pre-parsed and merged profile as dictionary to save one parsing round-trip
      let result = createSvgs(mergedProfile, options['--svg-target-dir'], options['--svg-name-prefix']);
      return new api.StringOutput(result);
    }
  });

API['controller:createImages'] = api.action({ '*1': 'file', '--target-dir': 1, '--name-prefix': 1 },
  (options, profileFile) => {
    let createSvgs = require('./config.libs/controllers.js').profileToImage;
    let result = createSvgs(profileFile, options['--target-dir'], options['--name-prefix']);
    return new api.StringOutput(result);
  });

API.btcPropDetails = api.action({ '#POS': 1 }, (options, propLine, value) => {
  let BTC_CONFIG_ROOT = require('./config.libs/config-import').BTC_CONFIG_ROOT;
  let SUPPORTED_SYSTEMS = require(BTC_CONFIG_ROOT + '/supported_systems.json');
  if (typeof value != "undefined") { propLine = `${propLine}=${value}` }
  let { analyseProperty } = require('./config.libs/parsing.js');

  let analysedProp = analyseProperty(propLine);
  let file = "system.conf";
  if (typeof SUPPORTED_SYSTEMS[analysedProp.effectiveKey[0]] == "object") {
    file = "emulators.conf";
  }

  log.debug("analysing", propLine, "results in", analysedProp);
  return Object.assign(analysedProp, { file: file });
});

API.configureRomPaths = api.action(
  { '--home': 'file', '--config-home': 'file', '--romdir': 1, '--comment': 1 }, (options) => {
    setHome(options['--home']);
    setConfigHome(options['--config-home']);
    setRomDir(options['--romdir']);

    let { BTC_BIN_DIR } = require('./config.libs/config-import.js');
    let systemWriter = require('./config.libs/output-formats.js').systems;

    let targetFile = `${getConfigHome()}/es_systems_99-paths.cfg`;
    let tmpOldFileName = `${targetFile}.${new Date().toISOString().replace(/\.\d{3}.*/, '')}`
    let configBackedUp = false;
    try {
      if (fs.existsSync(targetFile)) { fs.renameSync(targetFile, tmpOldFileName) }
      configBackedUp = true;

      let internalSystemConfig = `"${BTC_BIN_DIR}"/es_systems.cfg`;
      let systems = readSystemRomPaths(internalSystemConfig, USER_SYSTEM_CONFIGS);
      Object.entries(systems).forEach(e => systems[e[0]] = { path: resolveRomPath(e[1]) });
      systemWriter.write(systems, targetFile, {
        attributes: ['key', 'path'],
        comment: options['--comment'] || `Generated by 'btc-config configureRomPaths' from default es_systems.cfg and user drop-ins in ${getConfigHome()}`
      });

    } catch (e) {
      //in case of failure, restore previous config if possible
      log.error("Error during configuration of system paths - try to restore original files...");
      if (configBackedUp && fs.existsSync(targetFile)) { fs.unlinkSync(targetFile) }
      if (configBackedUp && fs.existsSync(tmpOldFileName)) { fs.copyFileSync(tmpOldFileName, targetFile) }
      throw e;
    } finally {
      if (configBackedUp && fs.existsSync(tmpOldFileName)) { fs.unlinkSync(tmpOldFileName) }
    }
  });

API.effectiveGlobals = api.action({
  '--format': ['sh', 'json', 'conf', 'yml', 'settings'],
  //for sh syntax
  '--strip-prefix': /\d+/,
  // which files to read and merge - and in the right order
  // default is system.conf,es_settings.cfg
  '--file-list': 'csv',
  //either a property file - root keys will be taken as filter or a regex
  '--filter': 1,
  '*1': ['get', 'set'],
  '2': { 'argsRemaining': [1, '[key]'] },
  '3': { 'argsRemaining': [1, '[value|default]'] },
}, (options, mode, key, value) => {
  const data = require('./config.libs/data-utils.js');
  const importer = require('./config.libs/config-import.js');
  const parseDict = require('./config.libs/parsing.js').parseDict;
  let writer;
  switch (mode) {
    case "get":
      let propertyFiles = options['--file-list'] || [
        `${importer.BTC_CONFIG_ROOT}/system.conf`,
        `${getConfigHome()}/es_settings.cfg`
      ];
      let transformer = (dict, name) => {
        if (name.endsWith('.conf')) {
          data.deepKeys(dict).forEach(dk => {
            let newVal = dk.get(dict);
            dk.set(dict, String(newVal))
          });
        }
        return dict;
      }
      let merged = importer.mergePropertyFiles(propertyFiles, { preMergeAction: transformer });
      if (key) {
        let hk = data.HierarchicKey.from(key);
        let result = hk.get(merged, value || '').valueOf();
        if (typeof result == 'undefined') { process.exit(1) }
        else if (typeof result != "object") { return new api.StringOutput(result) }
        else {
          merged = result;
          options['--filter'] ||= '.*';
        }
      }

      options['--filter'] ||= `${importer.DROPIN_PATH}/properties/00-supported_configs.json`;
      if (fs.existsSync(options['--filter'])) {
        let parseDict = require('./config.libs/parsing.js').parseDict;
        let filter = parseDict(options['--filter']);
        let old = merged;
        merged = {};
        Object.keys(filter).forEach(key => {
          if (!data.isEmpty(old[key])) { merged[key] = old[key] }
        })
      } else {
        let filter = new RegExp(options['--filter']);
        let imploded = data.deepImplode(merged);
        merged = {};
        Object.keys(imploded).filter(key => filter.test(key)).forEach(key => {
          let hk = data.HierarchicKey.from(key);
          hk.set(merged, imploded[key])
        })
      }

      writer = require('./config.libs/output-formats.js');
      writer[options['--format'] || 'conf'].write(merged, process.stdout, {
        stripPrefix: options['--strip-prefix']
      });

      break;
    case "set":
      if (typeof key == 'undefined'
        || typeof value == 'undefined') {
        throw '`set` requires key and value arguments';
      }
      let hk = data.HierarchicKey.from(key);
      if (process.geteuid() !== 0) { throw 'must be root' }
      //property will be saved to 2 files: 
      // 1. system.conf to prevent having to run a full merge just to change one property
      // 2. 99-admin-overrides.json to make the property survive the next run of `generateGlobalConfig`
      let systemConfFile = `${importer.BTC_CONFIG_ROOT}/system.conf`;
      let adminAdditionFile = `${importer.DROPIN_PATH}/properties/99-admin-overrides.conf`;

      let systemConf = parseDict(systemConfFile);
      let adminAdditions = importer.mergePropertyFiles([adminAdditionFile]);

      writer = require('./config.libs/output-formats.js');
      hk.set(systemConf, value);
      hk.set(adminAdditions, value);
      writer.conf.write(systemConf, systemConfFile, {
        comment: `Last change from 'btc-config effectiveGlobals set ${key}' on ${new Date().toISOString()}`
      });
      writer.conf.write(adminAdditions, adminAdditionFile);
      log.userOnly(`Written [${hk}=${value}] to\n * ${systemConfFile}\n * ${adminAdditionFile}`);
  }
});

API.effectiveProperties = api.action({
  '*--format': ['sh', 'json', 'conf', 'yml', 'settings'], '--system': 1,
  //for sh syntax
  '--strip-prefix': /\d+/,
  '--declare-fn': { 'argsRemaining': [1, 'shell-fn-name'] },
  //Debugging, not supported by all writers yet. Adds source file name as comment behind (or above, depending on supported syntax) to each property
  '--include-source': 0,
  '*1': { 'argsRemaining': [1, 'path/to/rom'] }
}, (options, relativeRomPath, ...controllerIds) => {
  const { BTC_CONFIG_ROOT } = require('./config.libs/config-import');
  const importer = require('./config.libs/config-import.js');

  // controllerIds is an array with strings in the format <guid>:"<name>"
  let romInfo = romInfoFromPath(relativeRomPath, options['--system'] || null);
  log.debug("found romInfo", romInfo)
  let folderConfigs = [romInfo.systemPath, ...romInfo.subfolders].map((val, key, r) => {
    if (key > 0) { r[key] = r[key - 1] + '/' + val }
    return r[key] + '/folder.conf'
  });
  //order matters because it controls the merge/overwrite priority
  let propertyFiles = [
    `${BTC_CONFIG_ROOT}/emulators.conf`,
    ...folderConfigs,
    //absPath is not required to be under systemPath in case another system was given with --system
    `${romInfo.absPath}/folder.conf`, `${romInfo.absPath}.conf`,
    `${getConfigHome()}/es_settings.cfg`
  ];

  let merged = importer.mergePropertyFiles(propertyFiles);
  if (typeof merged[romInfo.system] == "undefined") {
    throw new Error(`System ${romInfo.system} is not supported - no properties found.`)
  }

  _unwrapSpecificSubdict(merged[romInfo.system], 'folder', romInfo.subfolders.join('/'));
  _unwrapSpecificSubdict(merged[romInfo.system], 'game', romInfo.game);

  //now merge and pick all properties from default and system, folder and game have been merged into system already
  let effectiveResult = { [romInfo.system]: {} };
  let systemProps = effectiveResult[romInfo.system];
  Object.assign(systemProps, merged['default'] || {});
  data.mergeObjects(systemProps, merged['global'] || {});
  data.mergeObjects(systemProps, merged[romInfo.system] || {});
  effectiveResult.system = romInfo.system;
  effectiveResult.absRomPath = romInfo.absPath;

  if (controllerIds.length > 0) {
    let sdlStrings = importer.readControllerSDL(controllerIds)
    //ControllerConfig nested in PropValue. Configs are objects, but their strings shall be used, so transform first
    //otherwise shellwriter gets confused about the key hierarchy
    effectiveResult.batocera_sdl = sdlStrings.map(propValue => { return propValue.value = propValue.toString(), propValue });
  }

  let writer = require('./config.libs/output-formats.js');
  writer[options['--format']].write(effectiveResult, process.stdout, {
    declareCommand: options['--declare-fn'],
    stripPrefix: options['--strip-prefix'],
    printSource: options['--include-source']
  });
});

function _unwrapSpecificSubdict(container, subdictContainerKey, subdictKey) {
  let subdict = container[subdictContainerKey] || {}
  data.mergeObjects(container, subdict[subdictKey] || {});
  delete container[subdictContainerKey];
}

API.importBatoceraConfig = api.action({ '-o': 'file', '--comment': 1, '#POS': 1 }, (options, ...files) => {
  let cfgImport = ('./config.libs/config-import.js');
  let { basename } = require('node:path');

  let targetDir = options["-o"];

  //symlink target -> path
  let i = 0;
  let prefix = cfgImport.DROPIN_PATH + '/properties/01';
  let filesToImport;
  try {
    filesToImport = files.map(f => {
      let linkName = prefix + (i + "tmp-").padStart(6, '0') + basename(f);
      i++;
      let fileAbs = fs.realpathSync(f);
      fs.symlinkSync(linkName, fileAbs);
      return linkName;
    })
    cfgImport.generateGlobalConfig({
      '--comment': options['--comment']
        || 'Generated with import of additional files:' + filesToImport.join('\n')
    }, targetDir, null);
  } finally {
    filesToImport.filter(f => fs.existsSync(f)).forEach(f => fs.unlinkSync(f));
  }

});

API.generateGlobalConfig = api.action({ '--force': 0, '--comment': 1, '-v': 0 }, (options) => {
  let realFunc = require('./config.libs/config-import.js').generateGlobalConfig;
  return realFunc(options);
});

API['-h'] = API['--help'] = function() {
  //get full documentation, then re-execute the real help method
  //reason: help loads a lot of additional texts which are not required when another command is used.
  //doing this dynamically reduces the mininum amount of processing thats always required as overhead
  let help = require("./config.libs/cmdline-descriptions.js");
  API['-h'].description = help.printHelp.description;
  help.printHelp(...arguments);
}

// only run into the 'main' code the file is actually the one being executed
if (!process.argv.includes(__filename)) { return }

let args = process.argv.slice(2)
log.debug('FS_ROOT set to', FS_ROOT);
try {
  if (args.length == 0) args.push('--help');

  let modName = args[0];
  let fun = args[1];
  let composite = `${modName}:${fun}`;

  if (typeof API[modName] == "undefined" && typeof API[composite] == "undefined") {
    modName = '--help';
  }

  let result = typeof API[modName] == 'function'
    ? API[modName](...args.slice(1))
    : API[`${modName}:${fun}`](...args.slice(2));
  if (result && !(result instanceof api.ApiOutput)) { result = new api.JsonOutput(result) }
  log.apiOut(String(result || ''));
} catch (e) {
  let msg = e.message || e;
  let code = Number(msg) > 0 ? Number(msg) : 1;
  process.exit(code);
}
