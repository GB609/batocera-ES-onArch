# @file
# @brief Generic shell utils for logging
# @description
# The functions declared here will generally write to stderr.
# This allows to capture and process the regular output, e.g. by using `$()`.
# 
# The log functions will not reset exit codes of the executing script to 0.

# requires a log file name
[ -n "$1" ] || exit 1

# don't re-init if it was set already
[ -z "$LOGFILE" ] || return 0

LOGFILE="$1"
mkdir -p "$(dirname "$LOGFILE")"

exec 3>"$LOGFILE"

_hasFunc _logOnly || \
function _logOnly {
  local RET="$?"
  if echo "$@" >&3; then return "$RET"; fi
}

_hasFunc _logAndOut || \
function _logAndOut {
  _logOnly "$@"
  local RET="$?"
  if echo "$@" >&2; then return "$RET"; fi
}

_hasFunc _logAndOutWhenDebug || \
function _logAndOutWhenDebug {
  local RET="$?"
  if [ -n "$PRINT_DEBUG" ]; then
    _logOnly "$@"
    if echo "$@" >&2; then return "$RET"; fi
  fi
  return "$RET"
}

_hasFunc _pipeDebugLog || \
function _pipeDebugLog {
  local RET="$?"
  if [ -n "$PRINT_DEBUG" ]; then
    if tee -a "$LOGFILE" >&2; then return "$RET"; fi
  else
    if cat >&3; then return "$RET"; fi
  fi
}

_hasFunc _callstack || \
# @description Generate a call stack similar to how it is done in higher languages.
# @arg $1 message to print first (optional)
# @stdout generated stack 
function _callstack {
  [ -z "$1" ] || printf '%s\n' "$1"

  local idx="0"
  while [ -n "${BASH_LINENO[$idx]}" ]; do 
    local _line="${BASH_LINENO[$idx]}"
    local _file="${BASH_SOURCE[$idx+1]}"
    local _func="${FUNCNAME[$idx+1]:-main}"
    printf '\tat %s (%s:%d)\n' "$_func" "$_file" "$_line"
    # use pre-increment so that let won't return an error code of '0++'
    let ++idx 
  done
}

export -f _logOnly _logAndOut _logAndOutWhenDebug _pipeDebugLog _callstack