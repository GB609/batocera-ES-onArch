# SPDX-FileCopyrightText: 2025 Karsten Teichmann
#
# SPDX-License-Identifier: MIT

# @file
# This file contains a generic set of utility function that can be used for interaction with the user.  
# It automatically detects if used from a process connected to a terminal or not. If there is no terminal,
# message dialogs will be displayed.  
# Even if not connected to a terminal, console-based implementations will be used when there is no `$DISPLAY`

# @section Public API

# @description
# This is a proxy for other API functions contained in this library. Basically only invokes `ui:$1 "${@:2}"`.  
# For regular shell coding alone this is not required. However, all ui functions which produce messages
# do internally use [lc](./generic-utils.shl.md#lc) 
# with their arguments to generate localized messages.  
# `xgettext` which is used to collect message ids can't handle keywords containing ':'. 
# Thus, the code either would have to
# 1. manually call `lc` everywhere instead of encapsulating it, then pass to the ui methods
# 2. manipulate the input to `xgettext` on the fly to change keywords
# 3. or find some other keyword(s)
#
# Introducing the 'package prefix' as function by itself is solution 3, and it also allows to 'hide' strings from
# `xgettext`, by using the full function name, e.g. `ui:errorAbort`
function ui {
  # some methods are not yet migrated into the `ui` naming convention
  if _hasFunc "$1"; then
    "${1}" "${@:2}"
  else
    "ui:${1}" "${@:2}"
  fi
}

function ui:requestConfirmation {
  local _message="${1:-Are you sure?}"
  if [ "$#" -gt 0 ]; then shift; fi
  _message=$(lc "$_message" "$@")
 
  if "ui#isGraphical"; then
    "ui#baseDialog" --question --text="$_message" --ok-label="Yes" --cancel-label="No" --default-cancel
    return "$?"
  fi
  
  read -p "$_message [Y/n]? " -n 1 -r
  echo

  if [[ $REPLY =~ ^[Yy]$ ]]; then 
    "ui#resultOut" "true" && return 0
  else
    "ui#resultOut" "false" && return 1
  fi
}

# @description Get a single line from the user and keep as it is.
# @arg $1 string question to ask (lc pattern)
# @arg $2 string default value
# @arg $3 -$n lc replacements
function ui:ask {
  local msg=$(lc "$1" "${@:3}")
  local _default="$2"

  local _question=$(lc "%%msg%% (default: '%%_default%%')" msg _default)
  if "ui#isGraphical"; then
    REPLY="$('ui#baseDialog' --entry --text="$_question" --entry-text="$_default")"
  else
    echo '' >&2
    IFS='' read -ri "$2" -e -p "$_question"$'\n'": "
  fi

  "ui#resultOut" "${REPLY:-"$2"}"
}

# @description
# Ask the user to pick on of the choices given via stdin and/or subsequent arguments.
# The first argument is used as question to ask.  
# All subsequent arguments are divided into 2 'types' by the marker option `--choices`:
# - Anything **before** `--choices` is passed to `lc` after `$1` as replacer arguments
# - Anything **after** `--choices` is interpreted as if it was supplied on stdin .  
#   In case both are used, arguments from stdin will be listed first.
# 
# The function will echo the user's choice on stdout. To support localization, it is possible to print 
# a different text as what will be returned, when a string of the form `choice_id::choice_text` is given.  
# Automatically adds a 'none of them' choice at the end of the list. This will always return `ABORT` as value.
#
# When the environment variable `use_var` exists and contains a valid variable name, the result is
# written to that variable instead.
#
# @stdin lines in the form "simple string" or "some_key::simple string". Only read when not a terminal, up to 25 lines.
# @stdout choice_id of user's selection (defaults to choice_text)
# @arg $1 string prompt string
# @arg $2 - $n until '--choices' appears: replacer strings to pass to `lc` together with `prompt string`
# @option --choices all arguments following this will be interpreted as choices for the list
function ui:askChoice {
  ${ "ui#runLc" "$@"; } || __userMessage=$(lc 'Please pick one of the choices')
  [ "$1" != "--choices" ] || shift

  local __choices=('')
  local -a __textOverrides

  local index 
  (( index=0 )) || true
  while read -r line; do
    [ -n "$line" ] || continue
    __choices[++index]="${line%%::*}"
    __textOverrides[index]="${line#*::}"
  done <<EOF
$([ -t 0 ] && head -n 25)
$(printf '%s\n' "$@")
ABORT::$(lc "None of the given options")
EOF

  defPrompt="${__userMessage}"
  local _command
  _command=()
  if "ui#isGraphical"; then
    _command=("ui#choiceDialog")
    _command+=("${__userMessage}")
  else
    local prompt="" # temporary workaround, until 'ui:choiceTerminal' is fixed
    _command=("ui#choiceTerminal")
  fi

  local RESULT="0"
  while true; do
    RESULT=""
    RESULT=$(
      for (( i=1; i < "${#__choices[@]}"; i++ )); do 
        "ui#listChoice" "$i" "${__textOverrides[$i]}"
      done | "${_command[@]}"
    )

    # select abort when empty
    RESULT="${RESULT:-$index}"
    
    if [[ "$RESULT" -ge 0 ]] && [[ "$RESULT" -le "$index" ]]; then
      break
    fi
  done

  local selection_id="${__choices[$RESULT]}"
  _logAndOut $'\nyou picked: "%%1%%"' "${__textOverrides[$RESULT]}"

  "ui#resultOut" "$selection_id"
}

function ui:askDirectory {
  echo tbd
}

function ui:askFile {
  echo tbd
}

# @description Log a message and send it to the user, then exit shell
# @arg $1 string `lc` string
# @arg $2 -$n replacement strings (optional)
function ui:errorAbort {
  local msg=$(lc "$@")
  _logOnly "ERROR: %%1%%" "$(NO_LC=1 lc "$@")" || true
  if "ui#isGraphical"; then
    "ui#baseDialog" --error "--text=$msg" || true
  else
    # reset current status to prevent undesired executions of -e/-E through status propagation of log functions
    # not an issue because this is a controlled shutdown using regular `exit 1`
    true && _outOnly "ERROR: %%1%%" "$msg"
  fi
  exit 1
}

# @endsection

# @section Private functions

# @description
# Decides with backend to use based on tty and DISPLAY.  
# Called automatically at the end of this script. Does nothing on subsequent calls.
function ui#init 
{
  [ -v ui__interfaceBackend ] && return || true
  if tty -s || [ -z "$DISPLAY" ]; then
    ui__interfaceBackend="TTY"
    source "$SH_LIB_DIR"/ui/tty.shl
  else
    ui__interfaceBackend="GUI"
    source "$SH_LIB_DIR"/ui/gui.shl
  fi
}

# @description simple helper that can be used to determine if a graphical dialog shall be shown
function ui#isGraphical 
{ [ "$ui__interfaceBackend" = "GUI" ]; }

# @description
# Generalized handling of `$@` to split localization from other args.  
# - Usage: `${ "ui#runLc" "$@"; } || __userMessage=$(lc 'default translation')`  
#   Note: UNQUOTED, as the output is 1 command word +1 parameter word
# - Output:  
#    * Everything up to the first parameter starting with '--' is passed to `lc`
#    * The result is put into `__userMessage`
#    * Arguments passed to lc are counted
#    * If the separator was just `--`, it is also counted
# - Returns 1 when no translations arguments could be found
# @stdout some commands to manipulate positional arguments and define `__userMessage`
function ui#runLc
{
  local __lc_args=()
  while ! [[ "$1" =~ ^-- ]] && [ "$#" -gt 0 ]; do
    __lc_args+=("$1") && shift
  done
  local __consumed="${#__lc_args[@]}"

  # also consume --
  [ "$1" != "--" ] || { 
    (( __consumed+=1 ))
    shift 
  }
  
  # no localization
  [ "${#__lc_args[@]}" -gt 0 ] || {
    echo -n eval "local __userMessage=''; false"
    return 1
  }

  echo -n eval "local __userMessage='$(lc "${__lc_args[@]}")'; shift $__consumed; true"
}

# @description
# To be used by ui:askChoice. Encapsulates decision how and where to write the choices.
# $1 index
# $2 text
function ui#listChoice
{
  if "ui#isGraphical"; then
    printf '%s\n' FALSE "$1" "$2"
  else
    echo "$1: $2"
  fi
}

# @description
# Encapsulates handling of 'use_var' api switch.  
# Solely for usage from within ui actions which request input from the user.
function ui#resultOut 
{
  if ! [ -v use_var ]; then
    echo -n "$1"
  else
    local -n target="$use_var"
    # shellcheck disable=2034 # SC seems to have issues with 'local -n'
    target="$1"
  fi
}

# @endsection

"ui#init"
