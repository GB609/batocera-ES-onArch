#!/usr/bin/node

const fs = require('node:fs');
const resolve = require('node:path').resolve;
const log = require('./config.libs/logger.js').get();

const api = require('./config.libs/cmdline-api.js');
const data = require('./config.libs/data-utils.js');

Object.assign(globalThis, require('./config.libs/path-utils.js'));
globalThis.API = {};

globalThis.FS_ROOT = envOrVarAbsPath('FS_ROOT', __dirname + '/../..');

API.btcPropDetails = function(propLine, value) {
  let BTC_CONFIG_ROOT = require('./config.libs/config-import').BTC_CONFIG_ROOT;
  let SUPPORTED_SYSTEMS = require(BTC_CONFIG_ROOT + '/supported_systems.json');
  if (typeof value != "undefined") { propLine = `${propLine}=${value}` }
  let { analyseProperty } = require('./config.libs/parsing.js');

  let analysedProp = analyseProperty(propLine);
  let file = "system.conf";
  if (typeof SUPPORTED_SYSTEMS[analysedProp.effectiveKey[0]] == "object") {
    file = "emulators.conf";
  }

  log.debug("analysing", propLine, "results in", analysedProp);
  return Object.assign(analysedProp, { file: file });
}

API.configureRomPaths = api.action({ '--home': 'file', '--config-home': 'file', '--romdir': 1, '--comment': 1 }, (options) => {
  setHome(options['--home']);
  setConfigHome(options['--config-home']);
  setRomDir(options['--romdir']);

  let { BTC_BIN_DIR } = require('./config.libs/config-import.js');
  let systemWriter = require('./config.libs/output-formats.js').systems;

  let targetFile = `${getConfigHome()}/es_systems_99-paths.cfg`;
  let tmpOldFileName = `${targetFile}.${new Date().toISOString().replace(/\.\d{3}.*/, '')}`
  let configBackedUp = false;
  try {
    if (fs.existsSync(targetFile)) { fs.renameSync(targetFile, tmpOldFileName) }
    configBackedUp = true;

    let internalSystemConfig = `"${BTC_BIN_DIR}"/es_systems.cfg`;
    let systems = readSystemRomPaths(internalSystemConfig, USER_SYSTEM_CONFIGS);
    Object.entries(systems).forEach(e => systems[e[0]] = { path: resolveRomPath(e[1]) });
    systemWriter.write(systems, targetFile, {
      attributes: ['key', 'path'],
      comment: options['--comment'] || `Generated by 'btc-config configureRomPaths' from default es_systems.cfg and user drop-ins in ${getConfigHome()}`
    });

  } catch (e) {
    //in case of failure, restore previous config if possible
    log.error("Error during configuration of system paths - try to restore original files...");
    if (configBackedUp && fs.existsSync(targetFile)) { fs.unlinkSync(targetFile) }
    if (configBackedUp && fs.existsSync(tmpOldFileName)) { fs.copyFileSync(tmpOldFileName, targetFile) }
    throw e;
  } finally {
    if (configBackedUp && fs.existsSync(tmpOldFileName)) { fs.unlinkSync(tmpOldFileName) }
  }
});

API.effectiveProperties = api.action({
  '*--format': ['sh', 'json', 'conf', 'yml'], '--system': 1,
  '--strip-prefix': /\d+/, '--declare-fn': 1, //mostly for sh syntax
  //Debugging, not supported by all writers yet. Adds source file name as comment behind (or above, depending on supported syntax) to each property
  '--include-source': 0
}, (options, relativeRomPath, ...controllerIds) => {
  const { BTC_CONFIG_ROOT } = require('./config.libs/config-import');
  const importer = require('./config.libs/config-import.js');

  // controllerIds is an array with strings in the format <guid>:"<name>"
  let romInfo = romInfoFromPath(relativeRomPath, options['--system'] || null);
  log.debug("found romInfo", romInfo)
  let folderConfigs = [romInfo.systemPath, ...romInfo.subfolders].map((val, key, r) => {
    if (key > 0) { r[key] = r[key - 1] + '/' + val }
    return r[key] + '/folder.conf'
  });
  //order matters because it controls the merge/overwrite priority
  let propertyFiles = [
    `${BTC_CONFIG_ROOT}/emulators.conf`,
    ...folderConfigs,
    //absPath is not required to be under systemPath in case another system was given with --system
    `${romInfo.absPath}/folder.conf`, `${romInfo.absPath}.conf`,
    `${getConfigHome()}/es_settings.cfg`
  ];

  let merged = importer.mergePropertyFiles(propertyFiles);
  if (typeof merged[romInfo.system] == "undefined") {
    throw new Error(`System ${romInfo.system} is not supported - no properties found.`)
  }

  _unwrapSpecificSubdict(merged[romInfo.system], 'folder', romInfo.subfolders.join('/'));
  _unwrapSpecificSubdict(merged[romInfo.system], 'game', romInfo.game);

  //now merge and pick all properties from default and system, folder and game have been merged into system already
  let effectiveResult = { [romInfo.system]: {} };
  let systemProps = effectiveResult[romInfo.system];
  Object.assign(systemProps, merged['default'] || {});
  data.mergeObjects(systemProps, merged['global'] || {});
  data.mergeObjects(systemProps, merged[romInfo.system] || {});
  effectiveResult.system = romInfo.system;
  effectiveResult.absRomPath = romInfo.absPath;

  if (controllerIds.length > 0) {
    let sdlStrings = importer.readControllerSDL(controllerIds)
    //ControllerConfig nested in PropValue. Configs are objects, but their strings shall be used, so transform first
    //otherwise shellwriter gets confused about the key hierarchy
    effectiveResult.batocera_sdl = sdlStrings.map(propValue => { return propValue.value = propValue.toString(), propValue });
  }

  let writer = require('./config.libs/output-formats.js');
  writer[options['--format']].write(effectiveResult, process.stdout, {
    declareCommand: options['--declare-fn'],
    stripPrefix: options['--strip-prefix'],
    printSource: options['--include-source']
  });
});

function _unwrapSpecificSubdict(container, subdictContainerKey, subdictKey) {
  let subdict = container[subdictContainerKey] || {}
  data.mergeObjects(container, subdict[subdictKey] || {});
  delete container[subdictContainerKey];
}

API.importBatoceraConfig = api.action({ '-o': 'file', '--comment': 1 }, (options, ...files) => {
  let cfgImport = ('./config.libs/config-import.js');
  let { basename } = require('node:path');

  let targetDir = options["-o"];

  //symlink target -> path
  let i = 0;
  let prefix = cfgImport.DROPIN_PATH + '/properties/01';
  let filesToImport;
  try {
    filesToImport = files.map(f => {
      let linkName = prefix + (i + "tmp-").padStart(6, '0') + basename(f);
      i++;
      let fileAbs = fs.realpathSync(f);
      fs.symlinkSync(linkName, fileAbs);
      return linkName;
    })
    cfgImport.generateGlobalConfig({
      '--comment': options['--comment']
        || 'Generated with import of additional files:' + filesToImport.join('\n')
    }, targetDir, null);
  } finally {
    filesToImport.filter(f => fs.existsSync(f)).forEach(f => fs.unlinkSync(f));
  }

});

API.generateGlobalConfig = api.action({ '--comment': 1, '-v': 0 }, (options) => {
  let realFunc = require('./config.libs/config-import.js').generateGlobalConfig;
  return realFunc(options);
});

API['-h'] = API['--help'] = function() {
  //get full documentation, then re-execute the real help method
  let help = require("./config.libs/cmdline-descriptions.js");
  help.printHelp(...arguments);
}

let args = process.argv.slice(2)
if (args.length == 0) args.push('--help');
if (typeof API[args[0]] == "undefined") {
  args.unshift('--help');
}

log.debug('FS_ROOT set to', FS_ROOT);
try {
  let result = API[args[0]](...args.slice(1));
  if (result) { result = JSON.stringify(result, null, 2) };
  log.apiOut(result || '')
} catch (e) {
  let msg = e.message || e;
  let code = Number(msg) > 0 ? Number(msg) : 1;
  process.exit(code);
}
