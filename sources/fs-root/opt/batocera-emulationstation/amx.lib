# @file
# @description
# This file provides some basic utility methods needed for uniform control of AntiMicroX. 
# Because it only contains function definitions, it should be sourced. By default, functions contained
# are not exported, but will be if `export` is given as first argument when sourcing.  
# AMX is not just used for keybindings for games that don't support controllers.
# It will also run when `batocera-emulationstation` is active, but with a minimal profile
# whose sole responsibility is to handle the `guide` button of the controller.  
# Therefore, basic start, stop and profile change functions are separate from `emulatorlauncher` 
# because they are also needed from the `emulationstation` wrapper script for OS-level integration.  
# requires:
# - `logging.lib`
# - `CONFIG_ROOT`
# - `XDG_RUNTIME_DIR`
# - `ES_CACHE_DIR`
#
# For better test support: function declaration and export is dynamic - the script will check for each function
# if it is declared already and skip re-declaring when not.

_CONTROLLER_PROFILE_DIR="$CONFIG_ROOT"/batocera-emulationstation/controller-profiles
export _GUIDE_PROFILE="$_CONTROLLER_PROFILE_DIR"/GUIDE.gamecontroller.amgp

_hasFunc _amx:pid || \
# @description
# `emulatorlauncher` has to keep track of the PID of AntiMicroX instances it has started. 
# This function wraps the logic needed for that.
# - When no arg given: stdout current value
# - when numeric arg given: set/save as new PID
function _amx:pid {
  # FIXME: doesnt work because of the piping to _pipeDebugLog
  #if [ -n "$1" ]; then
  #  echo -n "$1" > "$XDG_RUNTIME_DIR"/amx.state
  #elif [ -f "$XDG_RUNTIME_DIR"/amx.state ]; then
  #  cat "$XDG_RUNTIME_DIR"/amx.state
  #else
    # fallback in case there is no state file
    pgrep antimicrox || exit 1
  #fi
}

_hasFunc _amx:applyGuide || \
# @description
# The profile passed to this function will be 'merged' with the GUIDE profile in a special way
# and the result will be cached.
# Checks if the merge is necessary at all, or if there exists an up-to-date pre-cached file already.
#
# @arg $1 file path to `.amgp` file
# @arg $2 player number specifier
# @stdout assoc with keys 'profile' and 'imgDir', in the format of `declare -p`
function _amx:applyGuide {
  declare -A _returnValue
  
  local _IMG_PREFIX="amx_mapping_${2:-ALL}"
  
  local _profileTitle="$(basename "${1%%.gamecontroller}")"
  local _relativeProfileName="${1##*controller-profiles/}"
  local _cachedFile="$ES_CACHE_DIR"/controller-profiles/"$_relativeProfileName"
  local _imgDir="$ES_CACHE_DIR"/controller-profiles/images/"${_relativeProfileName%%.gamecontroller*}"
    
  local _requiresMerge="true"
  # GUIDE does not need to be merged with itself
  if [ "$1" = "$_GUIDE_PROFILE" ]; then
    _requiresMerge="false"
    _cachedFile="$_GUIDE_PROFILE"
  fi
  
  _returnValue[imgDir]="$_imgDir"
  _returnValue[profile]="$_cachedFile"

  if [ "$_requiresMerge" = "true" ] && _amx:checkOutdated "$_cachedFile" "$1" "$_GUIDE_PROFILE"; then
    btc-config controller:applyGuide "$1" --name "$_profileTitle" --target-file "$_cachedFile" \
      --svg-target-dir "$_imgDir" --svg-name-prefix "$_IMG_PREFIX" | _pipeDebugLog \
      || _interface:errorAbort "Could not generate merged profile or mapping SVGs"
    declare -p _returnValue
    return 0
  fi
  
  shopt -s nullglob
  local _svgFileList=("$_imgDir"/*)
  shopt -u nullglob
  
  if _amx:checkOutdated "${_svgFileList[0]}" "$_cachedFile"; then
    btc-config controller:createImages "$_cachedFile" \
      --target-dir "$_imgDir" --name-prefix "$_IMG_PREFIX" | _pipeDebugLog \
      || _logAndOut "Could not recreate mapping SVGs - images might be outdated"
  fi

  declare -p _returnValue
}

_hasFunc _amx:exec || \
function _amx:exec {
  local id="$(_amx:pid)"
  [ 0 == "$?" ] && kill "$id"

  antimicrox --log-level warn "$@" | _pipeDebugLog
  # FIXME: doesnt work because of the piping to _pipeDebugLog
  #local pid="$!"
  #_amx:pid "$pid"
}

_hasFunc _amx:restart || \
# @description
# Make sure that AntiMicroX get's fully shut down and restarted again before the game.  
# **Reasons:** 
# 1. It's also based on SDL, as such it must use the mappings as they are provided by batocera for consistency (if there are any).  
#    But to achieve that, the `SDL_GAMECONTROLLERCONFIG` variable must be set when AMX launches.  
#    Any arguments passed to this function will just be forwarded to AMX.
# 2. AMX supports extended arguments, like `--startSet` which are meant to only change the active set of a controller.  
#    However, even these arguments don't work when AMX is running already. It has to be restarted and the profile must be passed again.  
#
# That means: To make sure AMX behaves as expected in terms of loading profiles and sets, it always has to be force-restarted.  
# The force-restart is taken care of in another core function, `_amx:exec`. The function `_amx:restart` is meant to prepare state data,
# like images and a marker of the current profile, so that restarts which just want to change the set, have something to work with.
#  
# This function also tries to find - or generate - controller mapping files for all profiles passed to amx
function _amx:restart {
  local _imgDirPrefix="$XDG_RUNTIME_DIR"/amx_controller_p
  local _profilePrefix="$XDG_RUNTIME_DIR"/amx_profile_p
  
  rm "$_imgDirPrefix"* 2>/dev/null || true
  rm "$_profilePrefix"* 2>/dev/null || true
  local _AMX_ARGS=()
  local arg
  local pnum=1
  for arg in "$@"; do
    if [[ "$arg" = *.amgp ]]; then
      source <(_amx:applyGuide "$arg" "$pnum")
      declare -p _returnValue | _pipeDebugLog
      _AMX_ARGS+=("${_returnValue[profile]}")
      _logOnly "LINK: ${_returnValue[imgDir]} to $_imgDirPrefix${pnum}"
      ln -s "${_returnValue[imgDir]}" "$_imgDirPrefix${pnum}"
      ln -s "${_returnValue[profile]}" "$_profilePrefix${pnum}"
      ((pnum++))
    else
      _AMX_ARGS+=("$arg")
    fi
  done
  unset _returnValue
  
  _amx:exec "${_AMX_ARGS[@]}"
}

_hasFunc _amx:guideMode || \
# @description
# This function 'resets' the controller profile used back to default.  
# The default is a special profile called `GUIDE`, which is always active, even outside games.  
# It contains only one button mapping in the first set: the `guide` button. This button will do 2 things when pressed:
# 1. shift to a secondary set which emulates keyboard buttons for menu navigation
# 2. press the `SUPER_L` button (or manually call some menu-displaying command)
# 3. The menu must shift back the control set when closing (not implemented yet).
function _amx:guideMode {
  _amx:restart \
    --hidden --tray \
    --profile "$_GUIDE_PROFILE" &
}

_hasFunc _amx:activateMenuGroup || \
# @description
# Changes the currently active profile to set 8, which is always assumed to be GUIDE menu navigation.  
# Works only for the first connected controller at the moment, no changes to others.  
# This function has to fully restart AMX and pass in the active profile in addition, so it is a relatively expensive operation.  
# The profile passed to AMX is `$XDG_RUNTIME_DIR/amx_profile_p1`, as prepared by `_amx:restart`
function _amx:activateMenuGroup {
  _amx:exec \
    --hidden --tray \
    --profile "$(readlink "$XDG_RUNTIME_DIR"/amx_profile_p1)" \
    --startSet 8 1 &
}

_hasFunc _amx:checkOutdated || \
# @description
# Because controller profiles in use are re-created dynamically, the mappings can also change, 
# which means that the corresponding SVG images would have to be re-created as well.  
# These are expensive operations and should only be performed when necessary, instead of
# whenever a game is launched/profile is changed.
#  
# That is why the profiles and images will be cached. But this requires a way to find out if
# recreation is necessary (cache is outdated). This function will do this.
# It works by doing a rudimentary check for modification times of the arguments passed, with the first argument
# serving as the 'target/generated' file:
# - When $1 is the most recent, return 1 - calling code would not have to recreate the file in question.
# - When any of $2-$n is more recent, return 0 - recreation is necessary.
# Strictly speaking, this is a very generic function and has no direct relation to AMX. 
# But it's the currently the only place that needs that kind of check.
#
# @arg $1 file the target file
# @arg $2-n file source file(s)
function _amx:checkOutdated {
  ## if the target does not even exist, it is 'outdated'
  [ -f "$1" ] || return 0
  local _targetFile="$1"
  local _targetDate=$(date -r "$1" '+%s')
  shift
  local _source
  local _sourceDate
  for _source in "$@"; do
    _sourceDate=$(date -r "$1" '+%s')
    [ "$_targetDate" -lt "$_sourceDate" ] && return 0
  done
  
  _logOnly "UPTODATE: $_targetFile"
  return 1
}

if [ "$1" = "export" ]; then
  _fnNames=($(declare -F | grep -oE '_amx.*'))
  for f in "${_fnNames[@]}"; do
    export -f "$f"
  done
fi