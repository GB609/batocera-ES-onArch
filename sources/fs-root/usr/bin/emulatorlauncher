#!/bin/bash

# @file
# @brief Central executable responsible for launching games
# @description The logic in this file grouped into several steps, most of which are internal implementation details.
#
# These steps are:
# 1. Parse command line
# 2. Determine and load effective properties for the game.
# 3. Configure [controls](../../dev/files/opt/emulatorlauncher/lib/.controls.lib.md)
# 4. Configure system/emulator
# 4. Execute additional [pre-game operations](emulatorlauncher-operations.md)
# 5. launch the game
# 6. post game events and clean-up
#
# See developer documentation for all specifics

if [ -z "$FS_ROOT" ]; then
  _scriptLoc=$(dirname $(realpath -s "$0"))
  FS_ROOT="${_scriptLoc%/usr/bin*}"
  unset _scriptLoc
fi

# load package path config
source "$FS_ROOT"/etc/batocera-paths.conf || exit 1

if [ "$#" -lt 2 ] || [ "$1" = "--help" ]; then
  echo "--- Usage: ---"
  echo "emulatorlauncher -rom <path/to/rom> [[-<propertyName> propertyOveride] ...] [[--<additionalOperation>] ...]"
  echo
  echo "Starts the given game. Reads and merges all properties and configurations from batocera.conf, folder-based overrides and user overrides."
  echo "This is mainly called from 'emulationstation', but can also be used from the console for debugging and testing purposes."
  echo
  echo "Any simple property that appears in a system's configuration can be force-overriden by passing it the to emulatorlauncher."
  echo "Properties given this way with a value != 'AUTO|auto' will not be taken from any configuration file."
  echo "'Simple' properties are those with the form 'systemName.propertyName' or those that do not contain a dot at all."
  echo "'emulationstation' uses 'system', 'emulator', 'core'."
  echo
  echo "'additionalOperations' are special actions that can be used to enhance or control the output and behavior of emulatorlauncher."
  echo "They are mostly intended for debugging or internal purposes when interacting with some other launcher scripts."
  echo "Additional operations will be executed in the order given after emulatorlauncher has finished all preparation steps."
  echo "They are the last actions to be run before the actual any real action (modifying properties, notifiying listeners, launching) is taken."
  echo "Current operations are:"
  echo " * 'effectiveProperties': Prints the result of merging all property source files in shell-style.  "
  echo "   For debugging only. emulatorlauncher normally sources this as code as one step of property calculation"
  echo " * 'launchConfiguration': Prints the launch command and all properties and configuration file (changes) that will be used to start the game"
  echo " * 'noRun': Just stop and exit. This is only useful in combination with 'effectiveProperties' or 'launchConfiguration'"
  exit 0
fi

source "$SH_LIB_DIR"/logging.lib "$ES_STATE_DIR"/emulatorlauncher.log
source "$SH_LIB_DIR"/amx.lib
source "$SH_LIB_DIR"/interaction_helpers.lib

set -eE
trap '_logAndOut "$(_callstack "Failed at [${BASH_COMMAND}]")"' ERR

_logAndOut "starting emulatorlauncher with args:[$@]"

# arrays for additional functions
_PRE_RUN_OPERATIONS=()
_POST_RUN_ACTIONS=()
_declaredVars=()
_launchPrefix=()

# $1: arr name
# $2: phase name
function _runCommandArray {
  local arrName="$1[@]"
  local cmd
  local IFS=$'\n'
  for cmd in "${!arrName}"; do
    cmd=($(xargs printf '%s\n' <<<$cmd ))
    _logOnly "[$2] $(printf '%q ' "${cmd[@]}")"
    "${cmd[@]}"
  done
}

# @internal
# @description In addition to the default preparation steps, there is a varying amount of additional steps that might have to be
# taken before a game can be launched. This function encapsulates that.  
# It will be called as the final step before launching a game, going over a list of commands that were registered as pre-run operations.
# The list is an array named `_PRE_RUN_OPERATIONS`, where any sourced file can add entries to, if required.  
# Operations passed to `emulatorlauncher` with the `--operationName` syntax will also be added here.
#   
# **Note:** When adding commands, be mindful of blanks. This function uses xargs/printf to retain quoted spaces.  
# E.g. "some-command -opt 'file with blanks' will be handled as `[some-command] [-opt] [file with blanks]`
function _preRunOperations {
  _runCommandArray _PRE_RUN_OPERATIONS PRE
}

# @internal 
# @section Helper functions
# This section describes a few helper functions used by `emulatorlauncher` at different places.

# @description Some actions need to always be executed when `emulatorlauncher` exits or crashes.  
# To do so, this function is registered as the main `EXIT` trap. When executed, it will loop over a well-known array of commands.  
# The array is named `_POST_RUN_ACTIONS` and its also possible to add commands to it from within sourced functions or system runners.  
#  
# **Note:** When adding commands, be mindful of blanks. This function uses xargs/printf to retain quoted spaces.  
# E.g. "some-command -opt 'file with blanks' will be handled as `[some-command] [-opt] [file with blanks]`
function _postRunActions {
  _runCommandArray _POST_RUN_ACTIONS POST
}
trap _postRunActions EXIT

# @description
# This function is meant to be used with `_PRE_RUN_OPERATIONS` and `_POST_RUN_ACTIONS`.  
# It is not possible to fork a new subprocess by suffixing '&' to a string entry of one of those arrays,
# It will be interpreted as argument instead of shell feature.  
# So, a function will be used as mapper instead, which will just pass through the command line prepend `&`
function _fork {
  "$@" &
}

# @description 
# emulatorlauncher needs a concept to prevent overriding of pre-defined variables.  
# This is required for handling overrides received via command line when `effectiveProperties` are sourced later on.
# To be more precise, what comes from the command line must have priority and be protected from being overridden later on. 
# However, due to the way regular bash read-onlys work, the script would crash and fail when the same declaration is encountered again.  
# `emulatorlauncher` stopping in that case is not desirable, the second assignment just should not have any effect.  
# This is where this function comes into play. It provides generic, codified support for checking before setting a variable 
# (or ignoring the second assignment otherwise).  
# **It is only meant for variables which represent 'game properties'** - There is no need to use it for every internal bash variable.  
#  
# This function also adds the name of variables given to it into an array named `_declaredVars`.
# This is mainly used for debugging and the operation `launchConfiguration` to distinguish 'game properties' from 'bash variables'.
# 
# Has two forms:
# 1. `declare-ro "name=value"`
# 2. `declare-ro -A "name"`
function declare-ro {
  if [ "-A" = "$1" ]; then
    local _flags="-gA" && shift
  fi
  local splitLine=(${1/=/ })
  local varname="${splitLine[0]}"
  if [ -z "${!varname}" ]; then
    declare ${_flags:--g} "$1"
    _declaredVars+=("$varname")
  else
    true && _logAndOut "Ignoring new declaration of pre-existing variable $varname"
  fi
}

# @description 
# Do some logging and source the given file.
# Primarily meant to source private .lib files and will assume a given simple name to be such a library.
# First checks the given file path itself for existence. When no file can be found, 
# certain well-known default locations will be prepended and checked for existence.
# @arg $1 path to file
function _sourceLib {
  _logAndOutWhenDebug "sourcing file: '$1'"
  if [ -e "$1" ]; then
    source "$1" || exit 1
  elif [ -e "$EL_PKG_DIR/lib/$1" ]; then
    source "$EL_PKG_DIR/lib/$1" || exit 1
  elif [ -e "$EL_PKG_DIR/$1" ]; then
    source "$EL_PKG_DIR/$1" || exit 1
  else
    _logAndOut "No library found: [$1]" && exit 1
  fi
  return 0
}

# @endsection

while [ "$#" -gt 0 ]; do
  if [[ "$1" =~ ^--.* ]]; then
    curOp="${1/--/}"
    opArgs=()
    while [ -n "$2" ] && ! [[ "$2" =~ ^--.* ]]; do
      opArgs+=("$2")
      shift
    done
    _PRE_RUN_OPERATIONS+=("$curOp ${opArgs[@]}")
  elif [[ "$1" =~ ^-[[:alpha:]].* ]]; then
    #arguments starting with - are mapped to variables of the same name. all can be used to override config values
    #first - is removed, all following mapped to _ instead
    varname="${1/-/}"
    varname="${varname//-/_}"
    if [ -n "$2" ] && ! [[ "$2" =~ auto|AUTO ]]; then
      declare-ro "$varname=$2"
    fi
    shift
  else
    _logOnly "ignore $1"
  fi

  shift
done
unset varname

if [ -z "$rom" ]; then
  _logAndOut "-rom path/to/rom is required at the very least."
  exit 1
fi

#----- Begin logic ------------------------------------------

ROMS_ROOT_DIR=${roms_dir:-$ROMS_ROOT_DIR}

if [ -z "$ROMS_ROOT_DIR" ]; then
  _logAndOut 'No env $ROMS_ROOT_DIR given and no parameter [-roms-dir path/to/rom-root] supplied - assuming default: ~/ROMs'
  _logAndOut 'ROMS_ROOT_DIR is used to resolve system and folder specific configuration'
fi

# @section 1. Load utility libraries
# @description 
# As first step of the logic, libraries which do not contain logic depending on game properties are loaded.
# @internal
_sourceLib "$SH_LIB_DIR"/user-paths.lib
_sourceLib .value-transformations.lib
_sourceLib .operations.lib
# @endsection


# @section 2. Rom-specific properties
# @description
# This is one of the most important steps when launching a game. After `emulatorlauncher` has finished basic setup,
# it has to retrieve all properties for the game from the merged system, folder and user settings.  
# The actual implementation of how the properties are loaded is contained in
# [effectiveProperties](%%DOC_ROOT%%/dev/files/opt/emulatorlauncher/lib/.operations.lib.md#effectiveProperties).  
# After these properties are loaded, some more helper variables will be derived from them:
# - `relativeRomPath`
# - `gamename` without extension or path
# - `GAME_SAVE_DIR`: The directory where saves for that game shall be placed  
# @internal
_fetchCmdOutOrFail _effProps effectiveProperties "$rom" \
  || _interface:errorAbort "No valid configuration found for [$rom]"
source <( echo "$_effProps" )
declare-ro "relativeRomPath=$(realpath -s --relative-to="$ROMS_ROOT_DIR" "$absRomPath")"
declare-ro "gamename=$(basename "$relativeRomPath")"
declare-ro "GAME_SAVE_DIR=${GAME_SAVE_DIR:-"$SAVES_ROOT_DIR/$relativeRomPath"}"
# @endsection


# BEGIN BLOCK: Helper scripts used to offload functionality
# Scripts are sourced so that they have full read and write access to all variables.
# This allows manipulation of existing properties or registering pre/post game hooks.
  _sourceLib .controls.lib
# END BLOCK


# BEGIN BLOCK: load system/emulator configurator
#This property shall be used by sourced emu configurators if they need to write properties
#to a file (or several) and when the emulator supports being passed a path to a file.
#This method of configuration shall be preferred over changing system or user default files
export CONFIG_FILE_PATH="$ES_STATE_DIR/$emulator"
rm -rf "$CONFIG_FILE_PATH"

# A key-value map of configurations to replace. Launch scripts can populate this when systems
# don't support a command line argument to point to different configuration files/directories.
# This is important because no temporary emulator configuration should overwrite the users general desktop configuration
# if the emulator is also in use outside of emulationstation.
# emulatorlauncher will make sure that the files are replaced before start and after end.
# The 'new' config files must be in a temporary path, and the parents directories of the sources must be writable/executable
#
# key will be the source file/directory
# value is the replacement to use
declare -A replaceConfigs=()

# mostly used for debug output and to be populated by the launcher script
configFiles=()

#expect emulator and core to be resolved now. source the configuration to get launchCommand
#all launcher configurations are expected to be in one of the name formats:
# - 'system_emulator_core.sh': requires system, emulator and core must be 'any' if optional
# - 'emulator_core.sh': requires emulator, core must be 'any' if optional
_logOnly "sourcing config for [s:$system, e:$emulator, c:$core] ..."
_emuConfigs=(
  "$EL_PKG_DIR"/"${system}_${emulator:-any}_${core:-any}.sh"
  "$EL_PKG_DIR"/"${system}_${emulator:-any}_any.sh"
  "$EL_PKG_DIR"/"${system}_any_any.sh"
  "$EL_PKG_DIR"/"${emulator}_${core:-any}.sh"
  "$EL_PKG_DIR"/"${emulator}_any.sh"
)

for cfg in "${_emuConfigs[@]}"; do
  ! [ -f "$cfg" ] && continue
  _sourceLib "$cfg" && break
done

if [ -z "$launchCommand" ]; then
  _interface:errorAbort "No configuration with a valid launchCommand found for [s:$system, e:$emulator, c:$core]. Exiting"
fi
# END BLOCK

_logOnly "starting game with command (length:${#launchCommand[@]}): [${launchCommand[@]}] ..."
if [ "$videomode" != "default" ] && which gamescope > /dev/null; then
  #FIXME: not working - need a new concept or ignore?
  res=(${videomode/x/ })
  scoping=('gamescope' '-w' ${res[0]} '-h' ${res[1]} '-f' '-b' '--')
  launchCommand=("${scoping[@]}" "${launchCommand[@]}")
fi

# execute additional pre-launch operations
_preRunOperations

# FIXME: the entire property replace logic is flawed and has to be replaced/rewritten
if [ "${#replaceConfigs[@]}" -gt 0 ]; then
  _logAndOut "emulator configuration has requested replacement of standard config files:"
  content=$(declare -p replaceConfigs)
  _logOnly "${content//\[/$'\n'  \[}"

  for origPath in "${!replaceConfigs[@]]}"; do
    tempTarget="${replaceConfigs[$origPath]}"

    mv "$origPath" "${origPath}.orig"
    #links don't need sudo, contrary to bind mounts
    ln -s -T "$tempTarget" "$origPath"
  done

  function revertConfigFileReplace {
    for origPath in "${!replaceConfigs[@]]}"; do
      [ -L "$origPath" ] && rm "$origPath"
      mv "${origPath}.orig" "$origPath"
    done
  }
  export -f revertConfigFileReplace

  _POST_RUN_ACTIONS+=('revertConfigFileReplace')
fi

_POST_RUN_ACTIONS+=('debugOutputOnError')
_POST_RUN_ACTIONS+=('notifyListener gameStop')

notifyListener gameStart

GAMELOG="$ES_STATE_DIR/emulatorlauncher/gamerun-${gamename}.log"
mkdir -p "$(dirname "$GAMELOG")"

launchCommand=("${_launchPrefix[@]}" "${launchCommand[@]}")
_logAndOut "Final launch command:\n" "${launchCommand[@]}"
"${launchCommand[@]}" 1>&2 2> "$GAMELOG"
launchResult=$?
# FIXME: might have to wait for launched program generically here
