# @file
# This file handles configuration and visibility of input devices, primarily controllers.  
# Can only run after effective properties for a game have been loaded.

# @description 
# When property `hide_mouse` is set and `unclutter` is installed:  
# -> Add `_controls:startUnclutter` to `_PRE_RUN_OPERATIONS`
#
# When executed:
# -> fork out `unclutter`
# -> add kill for unclutter's pid to `POST_RUN_ACTIONS`
function _controls:startUnclutter {
  unclutter --timeout 1 --jitter 3 --ignore-scrolling --hide-on-key-press &
  _unclutter_pid="$!"
  _POST_RUN_ACTIONS+=("kill $_unclutter_pid")
  unset _unclutter_pid
}
if _isTrue "$hide_mouse" && _hasBin unclutter; then
  _PRE_RUN_OPERATIONS+=(_controls:startUnclutter)
fi

# @description
# Used to filter a `gamecontrollerdb.txt` according to the guids and names of controllers assigned to players.  
# This is a utility function meant to be used from the logic setting up the SDL configuration.
# 1. Requires variables `p[1-8]guid` and `p[1-8]name`
# 2. Constructs a pattern in grep extended regex format out of them
# 3. runs grep against stdin
# @stdin `gamecontrollerdb.txt` format
# @stdout grep result
function _controls:sdl-filterDB {
  local -A filters
  for p in p{1..8}; do
    id="${p}guid"
    name="${p}name"
    [ -n "${!id}" ] && filters["$id"]=true
    [ -n "${!name}" ] && filters["$name"]=true
  done
  unset p
  local fullFilter=$(_join \| "${!filters[@]}")
  grep -E "$fullFilter" -
}

# @description
# This function allows to use an external executable to retrieve SDL configuration strings.  
# The expected executable name is `es-sdl` and it must be found on PATH.
# `es-sdl` It will be called once per controller and the final concatenated result is printed to stdout.
# @stdout `gamecontrollerdb.txt` format
# @see [external SDL provider](MANUAL:user/files/external-sdl.md)
function _controls:sdl-useExternal {
  if ! _hasBin es-sdl; then
    echo "";
    return
  fi
  sdl_strings=()
  for p in p{1..8}; do
    local id="${p}guid"
    local name="${p}name"
    [ "${!id}${!name}" = "" ] && continue
    sdl_strings+=("$(es-sdl system="$system" game="$relativeRomPath" guid="${!id}" name="${!name}")")
  done
  printf '%s\n' "${sdl_strings[@]}"
  unset p id name sdl_strings
}

# @section `$sdl_config`
# This property is evaluated in a switch-case statement.  
# The switch will mostly change `SDL_GAMECONTROLLERCONFIG` depending on the value of the property:
# - **db-global**: pull SDL configs from `$CONFIG_ROOT/batocera-emulationstation/gamecontrollerdb.txt`
# - **inherit**: do nothing. This allows to just take over what was supplied from the parent, if any
# - **none**: unset `SDL_GAMECONTROLLERCONFIG`
# - **external**: Uses the return value of [_controls:sdl-useExternal] 
# - **passthrough**: default. Take what effectiveProperties has calcaluted from es_input.cfg for the connected controllers. 
case "$sdl_config" in
  db-global)
    _globalDB="$CONFIG_ROOT"/batocera-emulationstation/gamecontrollerdb.txt
    SDL_GAMECONTROLLERCONFIG="$(_controls:sdl-filterDB < "$_globalDB")"
    unset _globalDB
    ;;
  inherit)
    # do nothing of note here
    _logAndOut "use SDL_GAMECONTROLLERCONFIG from parent process"
    ;;
  none)
    unset SDL_GAMECONTROLLERCONFIG
    ;;
  external)
    SDL_GAMECONTROLLERCONFIG="$(_controls:sdl-useExternal)"
    ;;
  passthrough|*)
    # assume there is an array called batocera_sdl - will be provided by effectiveProperties
    # this is a pre-filtered list of sdl strings
    SDL_GAMECONTROLLERCONFIG="$(printf '%s\n' "${batocera_sdl[@]}")"
    ;;
esac
[ -n "$SDL_GAMECONTROLLERCONFIG" ] && export SDL_GAMECONTROLLERCONFIG
# @endsection

# NOTE: AMX controller profile is incompatible with multiplayer
controller_profile=${controller_profile:-none}
if [ "$controller_profile" != "none" ]; then
  _logAndOut "TBD: disable/block controller inputs from game"
fi
#TBD:
#1. look up property value as profile name
#2. if it doenst exist, try to find and/or create game/system/emu specific
