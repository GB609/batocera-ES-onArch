#!/usr/bin/node

const fs = require('node:fs');
const resolve = require('node:path').resolve;
const log = require('logger').get();

const api = require('cmdline/api');
const data = require('utils/data');

Object.assign(globalThis, require('utils/path'));
globalThis.API = {};

require('batocera-paths');

API['controller:applyGuide'] = api.action(
  {
    //for profile merging 
    '*1': 'file', '--name': 1, '--target-file': { 'argsRemaining': [1, 'file'] },
    //when given, svg files will also be generated for the merged result
    //advantages: 
    // - avoids redundant reparsing of the xml file
    // - and the cost associated with calling 'btc-config'
    '--svg': 0, '--svg-target-dir': 1, '--svg-name-prefix': 1
  },
  (options, baseProfileName) => {
    let apply = require('controllers').applyGuideProfile;
    let mergedProfile = apply(baseProfileName, options['--name'] || false)

    let xmlTargetFile = options['--target-file'] || process.stdout;

    let xmlWriter = require('io/writers').xml;
    xmlWriter.write(mergedProfile, xmlTargetFile, {
      comment: `Generated by 'btc-config applyGuideProfile' from [${baseProfileName}]`
    });

    if (options.hasMatchingOptions('--svg.*')) {
      let createSvgs = require('controllers').profileToImage;
      //directly pass the pre-parsed and merged profile as dictionary to save one parsing round-trip
      let result = createSvgs(mergedProfile, options['--svg-target-dir'], options['--svg-name-prefix']);
      return new api.StringOutput(result);
    }
  });

API['controller:createImages'] = api.action({ '*1': 'file', '--target-dir': 1, '--name-prefix': 1 },
  (options, profileFile) => {
    let createSvgs = require('controllers').profileToImage;
    let result = createSvgs(profileFile, options['--target-dir'], options['--name-prefix']);
    return new api.StringOutput(result);
  });

API.btcPropDetails = api.action({ '#POS': 1 }, (options, propLine, value) => {
  let SUPPORTED_SYSTEMS = require(PATHS.CONFIG_ROOT + '/supported_systems.json');
  if (typeof value != "undefined") { propLine = `${propLine}=${value}` }
  let { analyseProperty } = require('io/parsers');

  let analysedProp = analyseProperty(propLine);
  let file = "system.conf";
  if (typeof SUPPORTED_SYSTEMS[analysedProp.effectiveKey[0]] == "object") {
    file = "emulators.conf";
  }

  log.debug("analysing", propLine, "results in", analysedProp);
  return Object.assign(analysedProp, { file: file });
});

API.configureRomPaths = api.action(
  { '--home': 'file', '--config-home': 'file', '--romdir': 1, '--comment': 1 }, (options) => {
    setHome(options['--home']);
    setConfigHome(options['--config-home']);
    setRomDir(options['--romdir']);

    let { BTC_BIN_DIR } = require('config-import');
    let systemWriter = require('io/writers').systems;

    let targetFile = `${getConfigHome()}/es_systems_99-paths.cfg`;
    let tmpOldFileName = `${targetFile}.${new Date().toISOString().replace(/\.\d{3}.*/, '')}`
    let configBackedUp = false;
    try {
      if (fs.existsSync(targetFile)) { fs.renameSync(targetFile, tmpOldFileName) }
      configBackedUp = true;

      let internalSystemConfig = `"${PATHS.BTC_BIN_DIR}"/es_systems.cfg`;
      let systems = readSystemRomPaths(internalSystemConfig, USER_SYSTEM_CONFIGS);
      Object.entries(systems).forEach(e => systems[e[0]] = { path: resolveRomPath(e[1]) });
      systemWriter.write(systems, targetFile, {
        attributes: ['key', 'path'],
        comment: options['--comment'] || `Generated by 'btc-config configureRomPaths' from default es_systems.cfg and user drop-ins in ${getConfigHome()}`
      });

    } catch (e) {
      //in case of failure, restore previous config if possible
      log.error("Error during configuration of system paths - try to restore original files...");
      if (configBackedUp && fs.existsSync(targetFile)) { fs.unlinkSync(targetFile) }
      if (configBackedUp && fs.existsSync(tmpOldFileName)) { fs.copyFileSync(tmpOldFileName, targetFile) }
      throw e;
    } finally {
      if (configBackedUp && fs.existsSync(tmpOldFileName)) { fs.unlinkSync(tmpOldFileName) }
    }
  });

API.effectiveGlobals = api.action(() => {
  let defaultOpts = require('effective-values').DEFAULT_API_OPTIONS;
  return defaultOpts.with({
    // which files to read and merge - and in the right order, default is system.conf,es_settings.cfg
    '--file-list': 'csv',
    //either a property file - root keys will be taken as filter or a regex
    '--filter': 1,
    '*1': ['get', 'set'],
    '2': { 'argsRemaining': [1, '[key]'] },
    '3': { 'argsRemaining': [1, '[value|default]'] },
  })
}, (options, ...params) => {
  let effectiveGlobals = require('effective-values').effectiveGlobals;
  return effectiveGlobals(options, ...params);
});

API.effectiveProperties = api.action(() => {
  let defaultOpts = require('effective-values').DEFAULT_API_OPTIONS;
  return defaultOpts.with({
    '--system': 1, '*1': { 'argsRemaining': [1, 'path/to/rom'] }
  })
}, (options, ...params) => {
  let effectiveProperties = require('effective-values').effectiveProperties;
  return effectiveProperties(options, ...params)
});

API.effectiveUserSettings = api.action(() => {
  let defaultOpts = require('effective-values').DEFAULT_API_OPTIONS;
  return defaultOpts.with({
    '*1': ['full', 'diff']
  })
}, (options, ...params) => {
  let effectiveUserSettings = require('effective-values').effectiveUserSettings;
  return effectiveUserSettings(options, ...params)
});

API.importBatoceraConfig = api.action({ '-o': 'file', '--comment': 1, '#POS': 1 }, (options, ...files) => {
  let cfgImport = ('config-import');
  let { basename } = require('node:path');

  let targetDir = options["-o"];

  //symlink target -> path
  let i = 0;
  let prefix = PATHS.DROPIN_DIR + '/properties/01';
  let filesToImport;
  try {
    filesToImport = files.map(f => {
      let linkName = prefix + (i + "tmp-").padStart(6, '0') + basename(f);
      i++;
      let fileAbs = fs.realpathSync(f);
      fs.symlinkSync(linkName, fileAbs);
      return linkName;
    })
    cfgImport.generateGlobalConfig({
      '--comment': options['--comment']
        || 'Generated with import of additional files:' + filesToImport.join('\n')
    }, targetDir, null);
  } finally {
    filesToImport.filter(f => fs.existsSync(f)).forEach(f => fs.unlinkSync(f));
  }

});

API.generateGlobalConfig = api.action({ '--force': 0, '--comment': 1, '-v': 0 }, (options) => {
  let realFunc = require('config-import').generateGlobalConfig;
  return realFunc(options);
});

API['-h'] = API['--help'] = function() {
  //get full documentation, then re-execute the real help method
  //reason: help loads a lot of additional texts which are not required when another command is used.
  //doing this dynamically reduces the mininum amount of processing thats always required as overhead
  let help = require("cmdline/help");
  API['-h'].description = help.printHelp.description;
  help.printHelp(...arguments);
}

// only run into the 'main' code the file is actually the one being executed
if (!process.argv.includes(__filename)) { return }

let args = process.argv.slice(2)
log.debug('FS_ROOT set to', PATHS.FS_ROOT);
try {
  if (args.length == 0) args.push('--help');

  let modName = args[0];
  let fun = args[1];
  let composite = `${modName}:${fun}`;

  if (typeof API[modName] == "undefined" && typeof API[composite] == "undefined") {
    modName = '--help';
  }

  let result = typeof API[modName] == 'function'
    ? API[modName](...args.slice(1))
    : API[`${modName}:${fun}`](...args.slice(2));
  if (result && !(result instanceof api.ApiOutput)) { result = new api.JsonOutput(result) }
  log.apiOut(String(result || ''));
} catch (e) {
  let msg = e.message || e;
  let code = Number(msg) > 0 ? Number(msg) : 1;
  process.exit(code);
}
