#!/bin/bash

# SPDX-FileCopyrightText: 2025 Karsten Teichmann
#
# SPDX-License-Identifier: MIT

# @file /usr/bin/emulationstation-wine
# @description wrapper script for handling of wine, reading batocera config files and handling all game file types

if [ "$#" -lt 2 ] || [ "$1" = "--help" ]; then
  echo "--- usage: ---"
  echo "emulationstation-wine <action> <rom> [-cfg path/to/sourceable/wine/envconfig] [-- args for <effective executable>, also works for installation]"
  echo
  echo "A re-implementation of batocera-wine which tries to keep the same API, in addition to new capabilities."
  echo "Flags that only exist for backwards-compatibility: 'play', '.w'tgz, '.w'squashfs, '.pc'"
  echo " * <action>: one of (run|play, install, import, config, tricks, explore, patch, cmd, mkAutorun)"
  echo " * run <rom>: path/to/rom[.wine|.pc|.(w)squashfs|.exe|.(w)tgz] - run directly"
  echo " * install <rom>: path/to/rom[.exe|.(w)tgz|.msi|.iso] - create prefix in library and guide through installation setup"
  echo " * import <rom>: path/to/rom.(w)tgz or directory - create prefix in library and copy content from given source. For zipped games without installers."
  echo " * <effective executable>: value of \${CMD}, either provided by autorun.cmd in game folder or passed in config file."
  echo -e " * <-cfg file>: a file that must be sourceable by bash containing wine/proton env variables.\n\tCan also be used to override values in autorun.cmd (if existing)"
  echo -e "\twhen no -cfg is given, this script will request config from emulatorlauncher to assure necessary args are set up correctly"
  exit 1
fi

EXIT_HOOKS=()
function _runExitHooks {
  for hook in "${EXIT_HOOKS[@]}"; do
    $hook
  done
}
trap _runExitHooks EXIT

if [ -z "$FS_ROOT" ]; then
  DIR=$(readlink -f "$0")
  DIR=$(dirname "$DIR")
  FS_ROOT=$(realpath "$DIR"/../..)
fi

source "$FS_ROOT"/opt/batocera-emulationstation/user-paths.lib
source "$FS_ROOT"/opt/emulatorlauncher/lib/.value-transformations.lib
source "$FS_ROOT"/opt/batocera-emulationstation/logging.lib "$ES_STATE_DIR/emulationstation-wine"

_action="$1"
[ "$_action" = "play" ] && _action="run"

shift
_target=$(realpath -s "$1")
shift

dllOverrides=('winemenubuilder=d')
#winePaths=()

if ! [ "$1" = "-cfg" ] || ! [ -f "$2" ]; then
  _logAndOutWhenDebug "No configuration file found, request config from emulatorlauncher..."
  source <( "$FS_ROOT"/usr/bin/emulatorlauncher -rom "$_target" --launchConfiguration --noRun ) || exit $?
  _configFile="${configFiles[0]}"
else
  _configFile="$2"
  shift 2
fi

source "$_configFile" || exit 1

if [ "$1" = "--" ]; then
  shift
  addArgs=("$@")
fi

_fileEnding=$(echo "${_target/*./}" | tr '[:upper:]' '[:lower:]')
gamename="${gamename/%.$_fileEnding/}"

# use the given mount fuse binary to mount to a dynamically generated mount name
# set mount point to variable _templatePrefix, adds an umount trap on EXIT
#$1: fuse binary
#$2: file to mount
#$3: optional - mount point
function _mountFuse {
  which "$1" 2>/dev/null || { _logAndOut "'$1' is not a valid fuse command!"; exit 1; }
  local mountPoint="$XDG_RUNTIME_DIR/emulationstation/mounts/$(uuidgen)"
  mountPoint="${3:-$mountPoint}"
  [ -d "$mountPoint" ] && fusermount3 -u "$mountPoint" | _pipeDebugLog
  mkdir -p "$mountPoint"
  "$1" "$2" "$mountPoint" | _pipeDebugLog
  EXIT_HOOKS+=("fusermount3 -uz '$mountPoint' && rmdir '$mountPoint'")
  echo "$mountPoint"
}

# type-specific preparations, also map multiple different supported endings of the same
# 'family' to one of the generic family names
# wine, exe, zip, iso, fs
case "$_fileEnding" in
  wine|pc)
    _fileEnding="wine"
    _templatePrefix=$(readlink -f "$_target")
    ;;
  wsquashfs|squashfs)
    _fileEnding="fs"
    _templatePrefix=$(_mountFuse squashfuse "$_target")
    ;;
  iso|nrg|img|mdf)
    _fileEnding="iso"
    _templatePrefix=$(_mountFuse fuseiso "$_target")
    ;;
  zip|tgz|wtgz)
    _fileEnding="zip"
    _templatePrefix=$(_mountFuse fuse-archive "$_target")
    ;;
  exe|msi|application)
    _fileEnding="exe"
    relativeRomPath="${relativeRomPath/windows_installers\//windows\/}"
    ;;
  *)
    _logAndOut "$_fileEnding not supported yet"
    exit 1
esac

LIB_DIR=${LIB_DIR:-"$ROMS_ROOT_DIR/$relativeRomPath"}
GAME_SAVE_DIR=${GAME_SAVE_DIR:-"$SAVES_ROOT_DIR/$relativeRomPath"}

# @internal
# @description Create wine prefix directory at location given.
#  Does not re-create the prefix if the file 'system.reg' already exists in the given directory.
#  Also exports given directory name as WINEPREFIX variable and calls _readWineAutorun as last step
#  If the WINE_DISC environment variable is set after _readWineAutorun, the disc image will be mounted
# @arg $1 directory that should be initialised as prefix
# @arg $2 - optional. one of
#           '--skip-creation':  Don't create the prefix even if it does not exist) 
#           '--no-export': Don't export given directory as WINEPREFIX, don't read & export from autorun.cmd
function _setupPrefix {
  local PREFIX=$(readlink -m "$1")
  if ! [ -f "$PREFIX/system.reg" ] && ! [ "$2" = "--skip-creation" ]; then
    _logAndOut "\n ***** Creating wine prefix *****"
    _logAndOut "* PREFIX: [$PREFIX]"
    mkdir -p "$PREFIX"
    _wine "$PREFIX" start /? | _pipeDebugLog
    WINEPREFIX="$PREFIX" winetricks -f -q isolate_home | _pipeDebugLog
  fi

  if [ "$2" = "--no-export" ]; then
    return 0
  fi
  export WINEPREFIX="$PREFIX"
  _readWineAutorun

  if [ -f "$WINE_DISC" ]; then
    local _discPath=$(_mountFuse fuseiso "$WINE_DISC")
  fi
}

## Creates a temporary directory structure containing dxvk to be used as lowerdir in an overlay mount
#: Checks architecture of given prefix directory and generates the temporary directory using bind mounts of system installed dxvk.
#: This @opt-requires(aur:dxvk-bin) and @opt-requires(aur:bindfs). The 'Enable DXVK' option will just not do anything otherwise.
#: But it would still be possible to install DXVK into a prefix manually, e.g. with winetricks. 
#: However, emulationstation-wine then has no way of detecting whether it is installed or not and can't uninstall/disable it either.
#: $1: wine prefix directory
#: @returns(absolute directory path, prefixed with ':', or empty if dxvk not installed)
function _generateDxvkLayer {
  if ! which setup_dxvk 2>/dev/null; then
    echo ''
    _logAndOut "dxvk-bin(aur) not installed - can't install DXVK"
    return 1
  fi

  if ! which bindfs 2>/dev/null; then
    echo ''
    _logAndOut "bindfs(aur) not installed - can't create DXVK layer"
    return 1
  fi

  local wineArch=$(grep -Eho '#arch=win[[:digit:]]+' "$1"/* | tail -n 1 | cut -d'=' -f2)
  local layerDir="$TMP_DIR/dxvk"

  local mountTargets=("$TMP_DIR/dxvk/dosdevices/c:/windows/system32")
  local dllDir="/usr/share/dxvk/x32";
  if [ "$wineArch" = "win64" ]; then
    dllDir="/usr/share/dxvk/x64"
    mountTargets+=("$TMP_DIR/dxvk/dosdevices/c:/windows/syswow64")
  fi

  for mp in "${mountTargets[@]}"; do
    mkdir -p "$mp"
    _mountFuse bindfs "$dllDir" "$mp" | _pipeDebugLog
  done

  for dll in "$dllDir"/*; do
    dllOverrides+=("${dll%.dll}=n")
  done

  echo "$layerDir"
}

# @section Handling of wine prefixes and saves
# @description Dealing with wine for a (potentially) shared game library introduces 2 issues that have to be solved.
# 1. Save games: Wine is just an execution layer, it does not directly control how - and where - an application will save its data.
# Applications don't do this in a uniform way. Save locations vary greatly, depending on the age of the game, targeted windows version
# also the frameworks in use. Some save in the user's home, some in a direct subdirectory etc.
# 2. Wine enforces a certain file ownership policy. It normally is not possible to run the same prefix for 2 users.
#
# emulationstation-wine will work around both limitations with the following approach:
# 1. There is a difference between a `libraryPrefix` and a `userPrefix`.
# 2. `libraryPrefix`: The game installations themselves, placed under the corresponding system's rom directory.
# 3. `userPrefix`: These are based on library prefixes, but use fuse and overlay mounts to create user-specific directory structures when starting a game. 
#
# While the game runs, all of its writes go into the overlay. This overlay will be decoupled when it stops.
# With that, it becomes possible to update/modify the library prefix without invalidating user saves in the overlay.
# 
# This approach has its limits and can fail when a file exists in both the library and the save and is modified differently in both.


# @description This function is responsible for configuring an action that targets a library prefix
# This normally only means to set `WINEPREFIX` to the game's directory under `ROMS_ROOT_DIR/system/...`.
# 1. Library prefixes can be owned by a shared user or group in a shared rom directory. 
# In that case, this method has to make sure that any command is actually executed by the owner of the group.
# Functions/commands that target library prefixes might need to ask for a user change or sudo privileges.
# 2. Library prefixes created by `emulationstation-wine install` will be isolated from the linux user's home directory.
# This is an important measure the handle correct redirection and capturing of save games.
# **Please do not directory create a library prefix manually without this step.**
#
# **This is an internal function that can not be called from the outside. Mentioned for documentation reasons here**
function _libraryPrefix {
  _setupPrefix "${WINEPREFIX:-$LIB_DIR}"
}

# shellcheck disable=SC2120
# @description This function sets up user prefixes from the given library rom prefix.
# As mentioned above, these are overlay-fs constructs (going from lowest to highest):
# 1. lower 1: The library prefix
# 2. lower 2: (optional) DXVK
# 3. upper: The user's save directory for the game
#
# After the game ended, the overlay fs will be deconstructed and the save directory converted back into a
# 'clean' directory structure without overlay fs meta informations.
# This makes it possible to allow modifications to the library prefix again.
#
# **This is an internal function that can not be called from the outside. Mentioned for documentation reasons here**
function _userPrefix {
  WINEPREFIX="${WINEPREFIX:-$GAME_SAVE_DIR}/prefix"
  mkdir -p "$GAME_SAVE_DIR"

  if [ -z "$_templatePrefix" ] || ! [ -d "$_templatePrefix" ]; then
    _templatePrefix="$GAME_SAVE_DIR/base_prefix"
    local requiresInit="true"
  fi

  if [ "$1" = "--vars-only" ]; then
    return 0
  fi

  [ -n "$requiresInit" ] && _setupPrefix "$_templatePrefix" --no-export || exit 1

  _initUserFromLib
}

function _delayerUserSave {

  if ! which rsync 2>/dev/null; then
    _logAndOut -e "rsync not installed - wine save can't be separated from overlay mount"
    return 1
  fi

  tmpDir="$GAME_SAVE_DIR/delayered"
  mkdir "$tmpDir"
  EXIT_HOOKS+=("rmdir '$tmpDir'")
  if rsync -ax --compare-dest="$_templatePrefix/" "$WINEPREFIX/" "$tmpDir/"; then
    fusermount3 -u "$WINEPREFIX" && (
      rm -rf "$GAME_SAVE_DIR/workdir"
      [ -d "$GAME_SAVE_DIR/save_data.bak" ] && rm -rf "$GAME_SAVE_DIR/save_data.bak"
      mv "$GAME_SAVE_DIR/save_data" "$GAME_SAVE_DIR/save_data.bak"
      mv "$tmpDir" "$GAME_SAVE_DIR/save_data" && rm -rf "$GAME_SAVE_DIR/save_data.bak"
    )
  fi

  fusermount3 -uz "$WINEPREFIX"
  rm -rf "$GAME_SAVE_DIR/workdir"
}

function _initUserFromLib {

  if ! [ -d "$_templatePrefix" ]; then
    _logAndOut "_initUserFromLib requires a template prefix, but was given '$_templatePrefix'"
    return 1
  fi

  mkdir -p "$WINEPREFIX" "$GAME_SAVE_DIR"/workdir

  local lowerdirs="$_templatePrefix"
  if _isTrue "$DXVK"; then
    lowerdirs="${lowerdirs}$(_generateDxvkLayer "$_templatePrefix")"
  fi
 
  if [ -d "$GAME_SAVE_DIR"/save_data.bak ] && ! [ -d "$GAME_SAVE_DIR"/save_data ]; then
    # previous attempt to delayer saves failed
    _logAndOut "Previous save extraction failed - restore save_data.bak"
    mv "$GAME_SAVE_DIR"/save_data.bak "$GAME_SAVE_DIR"/save_data
  fi

  mkdir -p "$GAME_SAVE_DIR"/save_data
  fuse-overlayfs \
    -o "lowerdir=${lowerdirs},upperdir=${GAME_SAVE_DIR}/save_data,workdir=${GAME_SAVE_DIR}/workdir"\
    "$WINEPREFIX"
  EXIT_HOOKS+=("_delayerUserSave")
  _setupPrefix "$WINEPREFIX" --skip-creation
}

function _readWineAutorun {
  if ! [ -f "$WINEPREFIX/autorun.cmd" ]; then
    return
  fi

  while IFS= read -r line; do
    firstChar=$(echo "$line" | cut -c1)
    [ "$firstChar" = "#" ] && continue

    # shellcheck disable=SC2206
    splitLine=(${line/=/})
    varname="WINE_${splitLine[0]}"
    if [ -z "${!varname}" ]; then
      declare "WINE_$line"
    fi
  done < "$WINEPREFIX/autorun.cmd"
}

#encapsulates calling the configured wine executable and setting up envs
# arg0 other WINEPREFIX dir
function _wine {
  export LC_ALL="${WINE_LANG:-$LANG}"

  # TODO: implement proper search for umu gameid
  export GAMEID="${WINE_GAMEID:-btc-$gamename}"
  WINE_DIR="${WINE_DIR:-.}"

  if [ -n "$WINE_ENV" ]; then
    source <( echo "$WINE_ENV" )
  fi

  WINEDLLOVERRIDES=$(_join , "$WINEDLLOVERRIDES" "${dllOverrides[@]}")
  export WINEDLLOVERRIDES

  _logAndOut -e "\n ***** Running [$@] *****"
  wineBin=${WINE_BINARY:-wine}
  $wineBin "$@" | _pipeDebugLog
  return "${PIPESTATUS[0]}"
}

#search case-insensitive for windows binary relative to $1
function _findExes {
  (
    cd "$1"
    find -L . -mount \
      \( -path '*/z:/*' -prune -o \
      -path '*/windows/*' -prune -o \
      -path '*/users/*' -prune \
      \) -o \( \
      -iname '*.exe' -o \
      -iname '*.msi' -o \
      -iname '*.application' \
      \) -print 2>/dev/null
  )
}

# @section Supported Actions
# @description The following actions can be passed to emulationstation-wine.
# All of these functions take the same argument line format:<br>
# `emulationstation-wine <function-name> <path/to/rom> [-cfg path/to/sourceable/wine/envconfig] [-- args for real executable]"`
# * `-cfg` is optional and usually an internal implementation detail
# * `--` and anything following it is optional and will be passed to the real `*.exe` that will be launched at the end
#
# However, these functions run against different targets (=WINEPREFIX), as explained in the section about prefixes.

# @description The main function: Start a game.  
# Targes user prefix, derived from the given library rom path.
function run {
#user
  _userPrefix

  cd "$_target"/"$WINE_DIR"
  _wine "$WINE_CMD" "${addArgs[@]}"
}

function explore {
#lib, u
#empty for now, start explorer or something
echo
}

function import {
echo
}

# @description Install a game. Asks a few questions to guide and improve automatic installation.
# 1. Creates a new library prefix from another library rom.
# 2. Installation source must be file/directory from the windows/windows_installers systems
# 3. Can handle setup exes, zip files, isos and plain copy
function install {
  source "$FS_ROOT"/opt/batocera-emulationstation/user-interface.shl
  LIB_DIR="$(dirname "$LIB_DIR")/${gamename}.wine"
  clear
  while true; do
    relativeRomPath="$(realpath -s -m --relative-to="$ROMS_ROOT_DIR" "$LIB_DIR")"
    _question="Where should the game be installed (path relative to $ROMS_ROOT_DIR)?"$'\n'
    relativeRomPath="$(_ask "$_question" "$relativeRomPath")"
    _installDir="$ROMS_ROOT_DIR/$relativeRomPath"
    if [[ "$_installDir" != *.wine ]]; then
      _logAndOut "[$_installDir] does not end with .wine"
    elif [ -e "$_installDir" ] && [ -n "$(ls "$_installDir")" ]; then
      _logAndOut 'Directory exists and is not empty. Please select another or abort+delete first.'
    else
      LIB_DIR="$_installDir"
      unset _installDir && break
    fi
  done
  _libraryPrefix

  case "$_fileEnding" in
    exe|msi|application)
      _installerBinary="$_target"
      ;;
    zip|iso|fs)
      local copyOption="NONE - copy files to installation directory"
      _installerBinary=$(_findExes "$_templatePrefix" \
        | _askChoice "Which is the installer executable?" \
        --choices "$copyOption")
      if [ "$copyOption" = "$_installerBinary" ]; then
        _installerBinary="cp"
      else
        _installerBinary="$_templatePrefix/$_installerBinary"
      fi
      ;;
    *)
      _logAndOut "$_fileEnding is not a valid type for installation"
      exit 1
      ;;
  esac

  local returnCode="1"
  if [ "cp" = "$_installerBinary" ]; then
    cp -r "$_templatePrefix"/* "$LIB_DIR"
    returnCode="$?"
  else
    (
      WINE_CMD=("_wine" "start" "/wait" "/unix" "$_installerBinary" "${addArgs[@]}")
      cd "$WINEPREFIX"
      "${WINE_CMD[@]}" || exit 1
      wineserver -k || exit 1
    )
    returnCode="$?"
  fi

  [ "$returnCode" != "0" ] && _logAndOut 'Installation failed' && exit 1

  mkAutorun
}

# @description This is a guided utility that can be used to create `autorun.cmd` files for wine applications.  
# Will automatically be started at the end of a new installation, but can also be triggered manually later on.
# Targets library prefixes. 
#
# If the `autorun.cmd` file shall be different for a user, it has to be patched manually.  
# **Note:** When changed manually for a user, changes in the file within the library prefix will NOT propagate to that user anymore.
function mkAutorun {
  source "$FS_ROOT"/opt/batocera-emulationstation/user-interface.shl
  _libraryPrefix

  while true; do
    clear
    echo -e 'Installation will now ask a few questions to complete the necessary configuration...\n' >&2
    _autorunLines=()
    echo 'Searching for executables within WINEPREFIX while ignoring nested mount points...' >&2
    _gameExe=$(_findExes "$WINEPREFIX/dosdevices" | _askChoice "Which is the game executable?")
    if [ "$_gameExe" != "ABORT" ]; then
      _exeRel="$(realpath --relative-to="$WINEPREFIX" "$WINEPREFIX/dosdevices/$_gameExe")"
    else
      _gameExe="$WINEPREFIX"
      while ! [ -f "$_gameExe" ]; do
        _gameExe=$(_ask "Manually specify the executable (resolved relative to $(pwd))" "$WINEPREFIX")
      done
      _exeRel="$(realpath --relative-to="$WINEPREFIX" "$_gameExe")"
    fi
    _workdir=$(cd "$WINEPREFIX" && _ask "Work dir (relative to $WINEPREFIX)" "$(dirname "$_exeRel")")
    _workdir=$(cd "$WINEPREFIX" && realpath --relative-to="$WINEPREFIX" "$_workdir")

    _argLine=("$(realpath --relative-to="$WINEPREFIX/$_workdir" "$WINEPREFIX/$_exeRel")")
    _argLine+=($(_ask 'Additional launch arguments (leave blank if none)'))
    _autorunLines+=("CMD='${_argLine[@]}'")

    _autorunLines+=("DIR=$_workdir")

    _lang=$(_ask "language (use system default if empty)")
    if [ -n "$_lang" ]; then
      _autorunLines+=("LANG=$_lang")
    else
      _autorunLines+=('#LANG=en_US')
    fi

    _envs=$(_ask 'additional env vars:')
    if [ -n "$_envs" ]; then
      _autorunLines+=("ENV=$_envs")
    else
      _autorunLines+=("#ENV=VAR1='something' VAR2=''")
    fi

    if [ "$_fileEnding" = "iso" ]; then
      if _confirm "Is the disc required to run the game?"; then
        DISC_PATH=$(realpath --relative-to="$ROMS_ROOT_DIR" "$_target")
        _autorunLines+=("DISC=$DISC_PATH")
      fi
    elif _confirm $'\n'"Does the game require a disk to run"; then
      # TODO: implement
      echo 'not implemented yet' >&2
    fi

    echo $'\n'"Resulting autorun.cmd in $WINEPREFIX:" >&2
    echo '----------' >&2
    printf '%s\n' "${_autorunLines[@]}" >&2
    echo '----------' >&2
    if _confirm $'\n'"Correct?"; then
      break
    fi
  done

  printf '%s\n' "${_autorunLines[@]}" > "$WINEPREFIX/autorun.cmd"
  unset _autorunLines _gameExe _exeRel _argLine _workdir _envs _exeRel
}

function patch {
  _libraryPrefix
}

#winecfg for the prefix, if possible
function config {
  _libraryPrefix
}

#manual tricks. shouldnt be needed for most stuff that umu handles.
function tricks {
  _libraryPrefix
}

#run arbitrary command within the wineprefix associated with the game/user
function cmd {
  _userPrefix

  cd "$_target"/"$WINE_DIR"
  _wine "${addArgs[@]}"
}

if [ "$_action" = "${_action/_/}" ]; then
  _logAndOut "running $_action"
  export WINEDLLOVERRIDES="${WINEDLLOVERRIDES};winemenubuilder.exe=d"
  $_action "$@"
else
  _logAndOut "direct call of internal utilities not permitted!"
fi
