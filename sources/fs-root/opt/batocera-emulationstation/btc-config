#!/usr/bin/node

const fs = require('node:fs');
const resolve = require('node:path').resolve;
const log = require('./config.libs/logger.js').get();

globalThis.envOrVarAbsPath = function(envName, varFallback){
  let path = varFallback;
  if (process.env[envName]) {
    path = process.env[envName] 
    log.userOnly(`using value of ${envName}=${path} instead of '${varFallback}'`)
  }
  if (fs.existsSync(path)) { return fs.realpathSync(path) }
  else { return resolve(path) }
}

const api = require("./config.libs/cmdline-api.js");
const data = require('./config.libs/data-utils.js');

Object.assign(globalThis, require('./config.libs/path-utils.js'));
globalThis.API = {};

globalThis.FS_ROOT = envOrVarAbsPath("FS_ROOT", __dirname + "/../..");

API.btcPropDetails = function(propLine, value) {
  let CONFIG_ROOT = require('./config.libs/config-import').CONFIG_ROOT
  let SUPPORTED_SYSTEMS = require(CONFIG_ROOT + '/supported_systems.json');
  if (typeof value != "undefined") { propLine = `${propLine}=${value}` }
  let { analyseProperty } = require('./config.libs/parsing.js');

  let analysedProp = analyseProperty(propLine);
  let file = "system.conf";
  if (typeof SUPPORTED_SYSTEMS[analysedProp.effectiveKey[0]] == "object") {
    file = "emulators.conf";
  }

  log.info("analysing", propLine, "results in", analysedProp);
  return Object.assign(analysedProp, { file: file });
}

API.configureRomPaths = api.action({ '--home' : 'file', '--config-home' : 'file', '--romdir': 1, '--comment': 1 }, (options) => {
  setHome(options['--home']);
  setConfigHome(options['--config-home']);
  setRomDir(options['--romdir']);

  let { BTC_BIN_DIR } = require('./config.libs/config-import.js');
  let systemWriter = require('./config.libs/output-formats.js').systems;

  let targetFile = `${getConfigHome()}/es_systems_99-paths.cfg`;
  let tmpOldFileName = `${targetFile}.${new Date().toISOString().replace(/\.\d{3}.*/, '')}`
  let configBackedUp = false;
  try{
    if(fs.existsSync(targetFile)){ fs.renameSync(targetFile, tmpOldFileName) }
    configBackedUp = true;

    let internalSystemConfig = `"${BTC_BIN_DIR}"/es_systems.cfg`;
    let systems = readSystemRomPaths(internalSystemConfig, USER_SYSTEM_CONFIGS);
    Object.entries(systems).forEach(e => systems[e[0]] = { path: resolveRomPath(e[1]) });
    systemWriter.write(systems, targetFile, {
        attributes: [key, path],
        comment: options['--comment'] || `Generated by 'btc-config configureRomPaths' from default es_systems.cfg and user drop-ins in ${getConfigHome()}`
      });
    
  } catch (e) {
    //in case of failure, restore previous config if possible
    log.error("Error during configuration of system paths - try to restore original files...");
    if(configBackedUp && fs.existsSync(targetFile)){ fs.unlinkSync(targetFile) }
    if(configBackedUp && fs.existsSync(tmpOldFileName)){ fs.copyFileSync(tmpOldFileName, targetFile) }
    throw e;
  } finally {
    if(configBackedUp && fs.existsSync(tmpOldFileName)){ fs.unlinkSync(tmpOldFileName) }
  }
});

API.effectiveProperties = api.action({
  '*--format': ['sh', 'json', 'conf', 'yml'], '--system': 1,
  '--strip-prefix': /\d+/, '--declare-fn': 1, //mostly for sh syntax
  //Debugging, not supported by all writers yet. Adds source file name as comment behind (or above, depending on supported syntax) to each property
  '--include-source': 0
}, (options, relativeRomPath) => {
  let romInfo = romInfoFromPath(relativeRomPath, options['--system'] || null);
  log.debug("found romInfo", romInfo)
  let folderConfigs = [ romInfo.systemPath, ...romInfo.subfolders ].map((val, key, r) => {
    if(key > 0) { r[key] = r[key-1]+'/'+val }
    return r[key] + '/folder.conf'
  });
  //order matters because it controls the merge/overwrite priority
  let propertyFiles = [
    `${FS_ROOT}/etc/batocera-emulationstation/emulators.conf`,
    ...folderConfigs,
    //absPath is not required to be under systemPath in case another system was given with --system
    `${romInfo.absPath}/folder.conf`, `${romInfo.absPath}.conf`,
    `${getConfigHome()}/es_settings.cfg`
  ];

  let merged = mergePropertyFiles(propertyFiles);
  if (typeof merged[romInfo.system] == "undefined") {
    throw new Error(`System ${romInfo.system} is not supported - no properties found.`)
  }

  _unwrapSpecificSubdict(merged[romInfo.system], 'folder', romInfo.subfolders.join('/'));
  _unwrapSpecificSubdict(merged[romInfo.system], 'game', romInfo.game);

  //now merge and pick all properties from default and system, folder and game have been merged into system already
  let effectiveResult = { [romInfo.system]: {} };
  let systemProps = effectiveResult[romInfo.system];
  Object.assign(systemProps, merged['default'] || {});
  data.mergeObjects(systemProps, merged['global'] || {});
  data.mergeObjects(systemProps, merged[romInfo.system] || {});
  effectiveResult.system = romInfo.system;
  effectiveResult.absRomPath = romInfo.absPath;

  let writer = require('./config.libs/output-formats.js');
  writer[options['--format']].write(effectiveResult, process.stdout, {
    declareCommand: options['--declare-fn'],
    stripPrefix: options['--strip-prefix'],
    printSource: options['--include-source']
  });
});

function _unwrapSpecificSubdict(container, subdictContainerKey, subdictKey) {
  let subdict = container[subdictContainerKey] || {}
  data.mergeObjects(container, subdict[subdictKey] || {});
  delete container[subdictContainerKey];
}

function mergePropertyFiles(files, options = {}) {
  let parser = require('./config.libs/parsing.js');
  let properties = {};
  options = Object.assign({ ignoreInvalid: true }, options);
  let preMerge = options.preMergeAction || (d => d);
  for (confFile of files) {
    if (!fs.existsSync(confFile)) {
      if (options.ignoreInvalid === true) {
        log.debug('skip missing file', confFile);
        continue
      }
      else { throw confFile + ' does not exist!' }
    }
    let confDict = parser.parseDict(confFile);
    data.mergeObjects(properties, preMerge(confDict));
  }

  return properties;
}

API.importBatoceraConfig = api.action({ '-o': 'file', '--comment': 1 }, (options, ...files) => {
  let cfgImport = ('./config.libs/config-import.js');
  let { basename } = require('node:path');

  let targetDir = options["-o"];

  //symlink target -> path
  let i = 0;
  let prefix = cfgImport.DROPIN_PATH + '/properties/01';
  let filesToImport;
  try {
    filesToImport = files.map(f => {
      let linkName = prefix + (i + "tmp-").padStart(6, '0') + basename(f);
      i++;
      let fileAbs = fs.realpathSync(f);
      fs.symlinkSync(linkName, fileAbs);
      return linkName;
    })
    cfgImport.generateGlobalConfig({
      '--comment': options['--comment']
        || 'Generated with import of additional files:' + filesToImport.join('\n')
    }, targetDir, null);
  } finally {
    filesToImport.filter(f => fs.existsSync(f)).forEach(f => fs.unlinkSync(f));
  }

});

API.generateGlobalConfig = api.action({ '--comment': 1 }, (options) => {
  let realFunc = require('./config.libs/config-import.js').generateGlobalConfig;
  return realFunc(options);
});

API['-h'] = API['--help'] = function() {
  //get full documentation, then re-execute the real help method
  let help = require("./config.libs/cmdline-descriptions.js");
  help.printHelp(...arguments);
}

let args = process.argv.slice(2)
if (args.length == 0) args.push('--help');
if (typeof API[args[0]] == "undefined") {
  args.unshift('--help');
}

log.debug("FS_ROOT set to", FS_ROOT);
log.apiOut(API[args[0]](...args.slice(1)) || '')
