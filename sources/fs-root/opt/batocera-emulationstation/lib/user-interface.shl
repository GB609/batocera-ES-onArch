# SPDX-FileCopyrightText: 2025 Karsten Teichmann
#
# SPDX-License-Identifier: MIT

# @file
# @description 
# This file contains a generic set of utility functions that can be used for interaction with the user.
# The basic concept is that the interaction functions provide an API which is fully independent of how the
# message/question is represented to the user at the end.  
# Therefore, no assumption about the style of representation shall be made by the code using these functions. 
# This allows `user-interface.shl` to choose how to interact, which means that it could also provide more 
# than just TTY or dialogs, e.g. use a socket based stream instead.
#
# **UI Styles**  
# `user-interface.shl` currently supports 2 styles of user interfaces:
# - tty: when stdin is a terminal or `$DISPLAY` is empty, `read` based questions are used
# - graphical: when not a tty
#
# **Common behaviour / API**
# - The first argument will always be the message/question to ask  
# - When used in the form `ui <action>` instead of `ui:<action>` (the real, full function name),  
#   `$1` will be picked up by `xgettext` as a translatable string automatically.
# - The first argument will always be passed to `lc` internally for localization.
# - Some functions also support passing additional replacer arguments to `lc`.  
#   Where to place them in the argument line might vary by function. 
# - Some functions also support a '--validator <cmd>' option, which allows to control if (and how) a value is accepted.  
#   The validator command will be split into words while honoring quotes, then it is executed with 1 more arguments:  
#   `"{cmd[@]}" "currentValue"`
#|    - Exit code 0: accept `currentValue`. Final value can be adjusted by stdout.
#|    - Exit code >0: reject/ask again. If the function supports a default value or another kind of initial value data,
#|      the output of stdout will be used as such.
#|      This allows to adjust/refine choices or mutate the default value, depending on the function.
# - How the user's response is returned can be controlled with the existence and value of a variable named `use_var`.  
#|    - When its value is a valid variable name, and the variable exists, the response is written to that variable.
#|    - Otherwise the response is simply printed to stdout
# - `stderr` should not be swallowed or redirected by the caller as some UI styles use it for messages to the user.

# @section Public API

# @description
# This is a proxy for other API functions contained in this library. Basically only invokes `ui:$1 "${@:2}"`.  
# For regular shell coding alone this is not required. However, all ui functions which produce messages
# do internally use [lc](./generic-utils.shl.md#lc) 
# with their arguments to generate localized messages.  
# `xgettext` which is used to collect message ids can't handle keywords containing ':'. 
# Thus, the code either would have to
# 1. manually call `lc` everywhere instead of encapsulating it, then pass to the ui methods
# 2. manipulate the input to `xgettext` on the fly to change keywords
# 3. or find some other keyword(s)
#
# Introducing the 'package prefix' as function by itself is solution 3, and it also allows to 'hide' strings from
# `xgettext`, by using the full function name, e.g. `ui:errorAbort`
function ui {
  # some methods are not yet migrated into the `ui` naming convention
  if _hasFunc "$1"; then
    "${1}" "${@:2}"
  else
    "ui:${1}" "${@:2}"
  fi
}

function ui:requestConfirmation {
  local _message="${1:-Are you sure?}"
  if [ "$#" -gt 0 ]; then shift; fi
  _message=$(lc "$_message" "$@")

  if "ui#isTX"; then
    "ui#formAddField" CHK "${use_var:?need var name for form}" "$_message" false
    return 0
  fi

  if "ui#requestConfirmationImpl" "$_message"; then 
    "ui#resultOut" "true" && return 0
  else
    "ui#resultOut" "false" && return 1
  fi
}

# @description Get a single line from the user and keep as it is.
# @arg $1 string question to ask (lc pattern)
# @arg $2 string default value
# @arg $3 -$n lc replacements
function ui:ask {
  local msg=$(lc "$1" "${@:3}")
  local _default="$2"

  local _question=$(lc "%%msg%% (default: '%%_default%%')" msg _default)

  if "ui#isTX"; then
    "ui#formAddField" "" "${use_var:?required in TX mode}" "$_question" "$_default"
    return 0
  fi
  
  if ! "ui#asReply" ui#requestInputImpl "$_question" "${__default}"; then
    [ "$1" = "--optional" ] || ui errorAbort 'An answer is required for this question.'
  fi

  "ui#resultOut" "${REPLY}"
}

# @description
# Ask the user to pick on of the choices given via stdin and/or subsequent arguments.
# The first argument is used as question to ask.  
# All subsequent arguments are divided into 2 'types' by the marker option `--choices`:
# - Anything **before** `--choices` is passed to `lc` after `$1` as replacer arguments
# - Anything **after** `--choices` is interpreted as if it was supplied on stdin .  
#   In case both are used, arguments from stdin will be listed first.
# 
# The function will echo the user's choice on stdout. To support localization, it is possible to print 
# a different text as what will be returned, when a string of the form `choice_id::choice_text` is given.  
# Automatically adds a 'none of them' choice at the end of the list. This will always return `ABORT` as value.
#
# When the environment variable `use_var` exists and contains a valid variable name, the result is
# written to that variable instead.
#
# @stdin lines in the form "simple string" or "some_key::simple string". Only read when not a terminal, up to 25 lines.
# @stdout choice_id of user's selection (defaults to choice_text)
# @arg $1 string prompt string
# @arg $2 - $n until '--choices' appears: replacer strings to pass to `lc` together with `prompt string`
# @option --choices all arguments following this will be interpreted as choices for the list
function ui:askChoice {
  ${ "ui#runLc" "$@"; } || __userMessage=$(lc 'Please pick one of the choices')
  [ "$1" != "--choices" ] || shift

  if "ui#isTX"; then
    # the array must be accessible from outside sub-processes in TX mode
    # so that verification and value reading works
    local -n __choices="${use_var:?need a variable name in TX mode}"
  else
    local __choices
  fi
  
  __choices=('')
  local -a __textOverrides

  local index 
  (( index=0 )) || true
  while read -r line; do
    [ -n "$line" ] || continue
    __choices[++index]="${line%%::*}"
    __textOverrides[index]="${line#*::}"
  done <<EOF
$([ -t 0 ] && head -n 25)
$(printf '%s\n' "$@")
ABORT::$(lc "None of the given options")
EOF

  if "ui#isTX"; then
    "ui#formAddField" CB "$use_var" "$__userMessage" "$(_join \| "${__textOverrides[@]}")"
    __VERIFIERS["$use_var"]="ui#verifyChoice $use_var"
    return 0
  fi

  local RESULT="0"
  while ! [[ "$RESULT" =~ ^[0-9]+$ ]] || [ -z "${__choices[$RESULT]}" ]; do
    RESULT=$("ui#requestChoiceImpl" "$__userMessage" __textOverrides 1 || echo -n "$index")
  done

  local selection_id="${__choices[$RESULT]}"
  _logAndOut $'\nyou picked: "%%1%%"' "${__textOverrides[$RESULT]}"

  "ui#resultOut" "$selection_id"
}

# @description
# Ask the user to provide the path to an existing directory.
# Will exit the script with an error message when no directory is provided (user cancels).
# The options currently have to appear in the order mentioned.
#
# Backend providers must implement `iu#requestDirectoryImpl`.
# @arg $1 string prompt string
# @arg $2 - $n until the first appearance of a long option (--, or one of the options defined)
# @option --default The question should fill this path as default / starting point.
# @option --optional script will not exit on user cancel, but return an empty string instead
function ui:askDirectory {
  ${ "ui#runLc" "$@"; } || __userMessage=$(lc 'Please select a directory')

  local __default=""
  if [ "$1" = "--default" ]; then
    __default="$2"
    shift 2
  fi

  if "ui#isTX"; then
    "ui#formAddField" DIR "${use_var:?required in TX mode}" "$__userMessage" "${__default:-"$HOME"}"
    return 0
  fi

  if ! "ui#asReply" ui#requestDirectoryImpl "$__userMessage" "${__default:-"$HOME"}"; then
    # TODO: it might be better to pass that check into the impl to include in repeat loop?
    [ "$1" = "--optional" ] || ui errorAbort 'Directory is required'
  fi

  "ui#resultOut" "$REPLY"
}

# @description
# Ask the user to provide the path to an existing file. 
# Will exit the script with an error message when no file is provided (user cancels).
# The options currently have to appear in the order mentioned.
#
# Backend providers must implement `iu#requestFileImpl`.
# @arg $1 string prompt string
# @arg $2 - $n until the first appearance of a long option (--, or one of the options defined)
# @option --default The question should fill this path as default / starting point.
# @option --types file endings (without leading dot)
# @option --optional script will not exit on user cancel, but return an empty string instead
function ui:askFile {
  ${ "ui#runLc" "$@"; } || __userMessage=$(lc 'Please select a file')

  local __default=""
  if [ "$1" = "--default" ]; then
    __default="$2"
    shift 2
  fi

  local -a __types
  if [ "$1" = "--types" ]; then
    shift
    while ! [[ "$1" =~ ^-- ]] && [ "$#" -gt 0 ]; do
      __types+=("$1") && shift
    done
  fi

  if ! "ui#asReply" ui#requestFileImpl "$__userMessage" "${__default:-"$HOME"}" "${__types[@]:-'*'}"; then
    # TODO: it might be better to pass that check into the impl to include in repeat loop?
    [ "$1" = "--optional" ] || ui errorAbort 'File is required'
  fi

  "ui#resultOut" "$REPLY"
}

# @description Log a message and send it to the user, then exit shell
# @arg $1 string `lc` string
# @arg $2 -$n replacement strings (optional)
function ui:errorAbort {
  local msg=$(lc "$@")
  _logOnly "ERROR: %%1%%" "$(NO_LC=1 lc "$@")" || true
  if "ui#isGraphical"; then
    "ui#baseDialog" --error "--text=$msg" || true
  else
    # reset current status to prevent undesired executions of -e/-E through status propagation of log functions
    # not an issue because this is a controlled shutdown using regular `exit 1`
    true && _outOnly "ERROR: %%1%%" "$msg"
  fi
  exit 1
}

# @description
# This function provides results for a full questionaire as a single transaction.  
# In theory, console based implementations can achieve the same by sequencing several questions.  
# The problem with this is that the `ui` functions are basically transparent in terms of representation, 
# code using them doesn't know if text representation or dialogs are used.
# When several pieces of information are needed at once, however, it might lead to a bad user experience when
# a GUI representation is used under the hood, as each question would pop up as a new dialog.  
# This is what this function attempts to prevent, in addition to abstracting away the 'ask-verify-OK/NOK' cycle.  
#
# **Basic invocation**  
#```
#|# Provide form via stdin, either by heredoc or other equivalent patterns.
#|ui:form <introduction> <<EOF
#|# No outer quotes or process substitution needed, this is handled by 'form'.
#|# Also do not use 'use_var' for form lines as it will be managed by 'form' internally!
#|varName=ui question-command 'quoted arg' "$expanded" [args...]
#|# more ...
#|EOF
#```
#
# `ui:form` internally decides on the strategy how the questions are to be represented. There are 2 styles:
# - `sequential`: Ask one question after the other, collecting result as they are returned.
# - `transactional`: The question functions are instead expect to add configuration strings to form-specific variables,  
#   which will be used at the end to build one singular 'form' command to execute.
#
# **Arguments to `form`** 
# - `introduction`: Will be used as title or brief description what the form is about. Shorter is better.    
#   Automatically recognized by `xgettext` and internally passed to `lc` when used in the form `ui form`.
# - `stdin`: All entry lines will be evaluated and the commands are used in a context-aware way.
#
# **Output**  
# - When a value for `use_var` is provided, the variable name given is expected to point to an assoc array.  
#   This array is then be populated in the form `arr[<varName>]=<user response>`.  
#   **Note:** The assoc MUST be declared by the calling code, or bash will create a normal array instead.
# - Otherwise a sourceable string containing a sequence of `declare` statements is emitted on stdout.  
#   One `declare` statement for each <varName>.
#
# **Validation**
# When in `transactional` mode, validations will be performed at the end after user confirmation.
# If any validation fails, the entire transaction is restarted.
#
# **TTY**
# - `introduction` is printed first
# - All values will be asked for in sequence and loop individually until their corresponding validator (if any) succeeds.
#
# **GUI**  
# Will internally utilize `yad --form` in a subshell loop whose exit criteria is based on `VALIDATORS`.
#
# **Implementation contracts**  
# This function declares a set of local variables and expects specific behavior from commands read on stdin (ui:action 
# functions). The general behaviour/flow is:
# - The variables serve as state/context variables to be used/populated across all atomic calls to ui actions.
# - `ui:form` decides if the configured questions shall be asked in sequence or in some kind of nested transaction  
#   like a dialog. `ui__formStrategy` will have the value `SEQ` or `TX` respectively.  
#   This can be checked more easily by using `ui#isTX`
# - All supported functions must test on `ui#isTX` where applicable and, instead of 'asking directly',  
#   add suitable configuration to the state variables when in TX mode.
# - After all configuration has been collected, the backend-specific function `ui#runFormImpl` will be executed.
#   This function is expected to know how to handle the content of the state variables and use it to run the
#   actual commands to provide the list of questions to the user all at once.  
#   It should only return after the user input was confirmed and verified (or cancelled).
#
# **Variables**  
# How the variables are used is mostly specific to the backend implementation. But they are declared here to achieve
# a common scoping.
# - [array] `__varNames`: `ui:form` internal. Corresponds to variables names given in input
# - [array] `__formCommands`: `ui:form` internal. Slightly adjusted variant of the form input.
# - The following variables are mostly intended for transaction based form implementations:
#|    - [array] `__FORM_ARGS`: arguments or parameters for `ui#runFormImpl`
#|    - [array] `__FORM_DATA`: Snapshot of the initial values (or those from the last iteration after verification fail)
#|    - [array] `__CONFIRM_PARAMETERS`: metadata needed to correctly connect `__FORM_DATA` with `__VERIFIERS`
#|    - [assoc] `__VERIFIERS`: For any action which must validate and/or convert user input
#
# @arg $1 string (optional) short header message
# @arg $2 -$n (optional) replacement strings for `lc`
function ui:form {
  local msg=$(lc "$@")
  msg="${msg:-"$(lc 'Please answer the following questions.')"}"
  
  if "ui#supportsTX"; then 
    local ui__formStrategy=TX
    local -ga __FORM_ARGS
    local -ga __FORM_DATA
    local -ga __CONFIRM_PARAMETERS
    local -gA __VERIFIERS
    exec 3</dev/null
  else
    local ui__formStrategy=SEQ
    exec 3</dev/tty
  fi

  local -a __varNames=()
  local -a __formCommands=()
  while read -r; do
    local _varname=${REPLY%%=*}
    local _cmd=${REPLY#*=}
    [ -n "$REPLY" ] || continue

    __varNames+=("$_varname")    
    __formCommands+=("use_var=${_varname} $_cmd")
  done

  # declare all form variables as locals and then run the commands of the input given on stdin (`varname=ui command`),
  # but prefixed with `use_var=varName` accordingly, so that validators and results are set up correctly.
  # The actual effect and behaviour of this block differs depending on `ui__formStrategy`
  # - In TX mode: The actions are expected to recognize being run in TX mode and only provide configuration
  #   arguments through `__FORM_ARGS`, `__FORM_DATA`, `__VERIFIERS` and `__CONFIRM_PARAMETERS`
  # - In SEQ mode: This will basically yield validated results directly, as all action types should be
  #   coded in a self-sufficient way, repeatedly asking and validating input if required.
  # shellcheck disable=1090
  source <(
    printf 'local %s=""\n' "${__varNames[@]}"
    printf '%s\n' "${__formCommands[@]}" 
  ) <&3

  if "ui#isTX"; then
    local -A __form_result
    "ui#runFormImpl" "$msg" || return "$?"

    #after loop
    for n in "${__varNames[@]}"; do
      unset "$n"
      local "$n=${__form_result[$n]}"
    done
  fi

  # handling result
  if ! [ -v use_var ]; then
    # The printf itself should not expand, it generates code to be sourced.
    # Reason: What is needed here is not the expansion of the array of var names, 
    # but **sourceable** output printing assignment statements for the referenced vars.
    # shellcheck disable=1090,2016
    source <( printf 'echo ${%s[@]@A}\n' "${__varNames[@]}" )
  else
    local -n target="$use_var"
    for _varname in "${__varNames[@]}"; do
      target["$_varname"]="${!_varname}"
    done 
  fi
}

# @endsection

# @section Value verifier functions
# @internal
# @description
# The functions defined in this section are intended to be used from inside any `ui:*` or `uu#*` function where required.  
# Their primary purpose is to verify user input.  
#
# All verifier functions follow the same basic behaviour:
# 1. exit status expresses if the verification passes (0) or fails (!=0)
# 2. stdout is used to return an adjusted value.  
#    This is useful as feedback in loops to correct wrong input or in situations where the value represented to the
#    user does not match the 'internal' value required by the calling function.

# @description
# Verifies that the given argument is a none-empty path to an existing directory.  
# When the given path is not a valid directory, the verification prints the parent directory (if any) and fails.
# @arg $1 path supposed directory path to check
function ui#verify_isDir
{
  [ -n "$1" ] || return 1
  [ -d "$1" ] || { dirname "$1" && return 1; }
  echo -n "$1"
}

# @description
# Verify that a given string is a file path+name whose ending matches a pattern list.  
# The check will automatically append `$` at the end of the pattern.  
# **Note:** This function uses `()` instead of `{}` for the function body
# because it changes shell options to configure case insensitive matching.
#
# @stdout empty in case of verification failure, the full file path otherwise.
# @arg $1 regex OR pattern of expected file endings as accepted by `[[ =~ ]]` (`T1|T2`)
# @arg $2 path supposed file path to check
function ui#verify_isFileType
(
  shopt -s nocasematch
  [ -n "$2" ] || return 1
  if [ -f "$2" ] && [[ "$2" =~ \.($1)$ ]]; then
    echo -n "${2}"
  else
    dirname "$2" && return 1
  fi
)

# @endsection

# @section Private functions
# @internal

# @description
# Decides with backend to use based on tty and DISPLAY.  
# Called automatically at the end of this script. Does nothing on subsequent calls.
function ui#init 
{
  [ -v ui__interfaceBackend ] && return || true
  # pull in 'abstract' implementations first to get errors for unsupported/unimplemented functions
  # also useful for dev time to see expected API in a centralised place as the bash-language-server (or shellcheck)
  # seem to use the documentation of the first definition they find.
  source "$SH_LIB_DIR"/ui/backend-api.shl

  if tty -s || [ -z "$DISPLAY" ]; then
    ui__interfaceBackend="TTY"
    source "$SH_LIB_DIR"/ui/tty.shl
  else
    ui__interfaceBackend="GUI"
    source "$SH_LIB_DIR"/ui/gui.shl
  fi
}

# @description simple helper that can be used to determine if a graphical dialog shall be shown
function ui#isGraphical 
{ [ "$ui__interfaceBackend" = "GUI" ]; }

# @description
# When status=0, there is an ongoing process of building a `form` or `transaction`.
function ui#isTX
{	[ "$ui__formStrategy" = "TX" ]; }

# @description
# Generalized handling of `$@` to split localization from other args.  
# - Usage: `${ "ui#runLc" "$@"; } || __userMessage=$(lc 'default translation')`  
#   Note: UNQUOTED, as the output is 1 command word +1 parameter word
# - Output:  
#    * Everything up to the first parameter starting with '--' is passed to `lc`
#    * The result is put into `__userMessage`
#    * Arguments passed to lc are counted
#    * If the separator was just `--`, it is also counted
# - Returns 1 when no translations arguments could be found
# @stdout some commands to manipulate positional arguments and define `__userMessage`
function ui#runLc
{
  local __lc_args=()
  while ! [[ "$1" =~ ^-- ]] && [ "$#" -gt 0 ]; do
    __lc_args+=("$1") && shift
  done
  local __consumed="${#__lc_args[@]}"

  # also consume --
  [ "$1" != "--" ] || { 
    (( __consumed+=1 ))
    shift 
  }
  
  # no localization
  [ "${#__lc_args[@]}" -gt 0 ] || {
    echo -n eval "local __userMessage=''; false"
    return 1
  }

  echo -n eval "local __userMessage='$(lc "${__lc_args[@]}")'; shift $__consumed; true"
}

# @description
# Encapsulates handling of 'use_var' api switch.  
# Solely for usage from within ui actions which request input from the user.
function ui#resultOut 
{
  if ! [ -v use_var ]; then
    echo -n "$1"
  else
    local -n target="$use_var"
    # shellcheck disable=2034 # SC seems to have issues with 'local -n'
    target="$1"
  fi
}

# @description
# Executes command given as `$@` in the current environment and assigns it stdout to `REPLY`.  
# Uses the `new` command substitution syntax `${ CMD; }`, so it will be executed in the current process. 
# This makes it compatible with `read` as well. So it can be used to retrieve the value of any command
# as `REPLY`, regardless of whether the command writes to stdout or into the variable.  
# When the command prints to `stdin` AND writes to `REPLY`, `stdin` takes priority.
#
# @exitcode as returned by wrapped command
# @requires bash 5.3
function ui#asReply
{
  REPLY=""
  local __result __status
  __result=${ "$@"; };
  __status="$?"
  REPLY="${__result:-"$REPLY"}"
  return "$__status"
}

# @endsection

"ui#init"
