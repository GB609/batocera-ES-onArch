# @file
# This file handles configuration and visibility of input devices, primarily controllers.  
# Can only run after effective properties for a game have been loaded.

# @description 
# When property `hide_mouse` is set and `unclutter` is installed:  
# -> Add `_controls:startUnclutter` to `_PRE_RUN_OPERATIONS`
#
# When executed:
# -> fork out `unclutter`
# -> add kill for unclutter's pid to `POST_RUN_ACTIONS`
function _controls:startUnclutter {
  unclutter --timeout 1 --jitter 3 --ignore-scrolling --hide-on-key-press &
  _unclutter_pid="$!"
  _POST_RUN_ACTIONS+=("kill $_unclutter_pid")
  unset _unclutter_pid
}
if _isTrue "$hide_mouse" && _hasBin unclutter; then
  _PRE_RUN_OPERATIONS+=(_controls:startUnclutter)
fi

# @description
# Used to filter a `gamecontrollerdb.txt` according to the guids and names of controllers assigned to players.  
# This is a utility function meant to be used from the logic setting up the SDL configuration.
# 1. Requires variables `p[1-8]guid` and `p[1-8]name`
# 2. Constructs a pattern in grep extended regex format out of them
# 3. runs grep against stdin
# @stdin `gamecontrollerdb.txt` format
# @stdout grep result
function _controls:sdl-filterDB {
  local -A filters
  for p in p{1..8}; do
    id="${p}guid"
    name="${p}name"
    [ -n "${!id}" ] && filters["$id"]=true
    [ -n "${!name}" ] && filters["$name"]=true
  done
  unset p
  local fullFilter=$(_join \| "${!filters[@]}")
  grep -E "$fullFilter" -
}

# @description
# This function allows to use an external executable to retrieve SDL configuration strings.  
# The expected executable name is `es-sdl` and it must be found on PATH.
# `es-sdl` It will be called once per controller and the final concatenated result is printed to stdout.
# @stdout `gamecontrollerdb.txt` format
# @see [external SDL provider](MANUAL:user/files/external-sdl.md)
function _controls:sdl-useExternal {
  if ! _hasBin es-sdl; then
    echo "";
    return
  fi
  sdl_strings=()
  for p in p{1..8}; do
    local id="${p}guid"
    local name="${p}name"
    [ "${!id}${!name}" = "" ] && continue
    sdl_strings+=("$(es-sdl system="$system" game="$relativeRomPath" guid="${!id}" name="${!name}")")
  done
  printf '%s\n' "${sdl_strings[@]}"
  unset p id name sdl_strings
}

# @section `$sdl_config`
# This property is evaluated in a switch-case statement.  
# The switch will mostly change `SDL_GAMECONTROLLERCONFIG` depending on the value of the property:
# - **db-global**: pull SDL configs from `$CONFIG_ROOT/gamecontrollerdb.txt`
# - **inherit**: do nothing. This allows to just take over what was supplied from the parent, if any
# - **none**: unset `SDL_GAMECONTROLLERCONFIG`
# - **external**: Uses the return value of [_controls:sdl-useExternal] 
# - **passthrough**: default. Take what effectiveProperties has calcaluted from es_input.cfg for the connected controllers. 
case "$sdl_config" in
  db-global)
    _globalDB="$CONFIG_ROOT"/gamecontrollerdb.txt
    SDL_GAMECONTROLLERCONFIG="$(_controls:sdl-filterDB < "$_globalDB")"
    unset _globalDB
    ;;
  inherit)
    # do nothing of note here
    _logAndOut "use SDL_GAMECONTROLLERCONFIG from parent process"
    ;;
  none)
    unset SDL_GAMECONTROLLERCONFIG
    ;;
  external)
    SDL_GAMECONTROLLERCONFIG="$(_controls:sdl-useExternal)"
    ;;
  passthrough|*)
    # assume there is an array called batocera_sdl - will be provided by effectiveProperties
    # this is a pre-filtered list of sdl strings
    SDL_GAMECONTROLLERCONFIG="$(printf '%s\n' "${batocera_sdl[@]}")"
    ;;
esac
[ -n "$SDL_GAMECONTROLLERCONFIG" ] && export SDL_GAMECONTROLLERCONFIG
# @endsection

# @section Configuration of antimicrox
# This part of the logic contains a set of functions and switch-case blocks that handle controller replacment by AntiMicroX.  
# Actually using AMX requires several steps when starting a game:
# 1. Make sure SDL config is correct
# 2. locate the profile to use. User-based profiles might have to be created first
# 3. Restart AMX with another profile
# 4. Make sure the game does not get controller events
# 5. Restart AMX in "GUIDE" mode after the game ends  
#
# Not all steps of this procedure all encapsulated in functions. Some are just a list of statements following
# the function declarations. As such, they are not documented in more detail here.
#
# Aside from use in-game, AMX will also have to run all the time even when batocera itself is up.  
# **Reason:** The `guide`-button will be handled by AMX. This is easier to manage than having to re-configure X or Wayland etc.
# @see [AntiMicroX](https://github.com/AntiMicroX/antimicrox)

# @description
# When the setting `controller_profile` has any game-, emulator- or system-specific value,
# the corresponding profile is normally user-specific and thus part of user saves.  
# This function assists in creating new profiles, to make sure they are in line with a certain set of required keybinds.  
# **Reason:** To ensure that the `guide` button works uniformly across all apps and games (for os-wide intervention),
# it has to be defined in ALL profiles in the same way.  
# Thus, new profiles should be based on a template, OR be patched afterwards to correct misconfigurations done by the user.
# @arg (string) realm of user defined, one of `u-game`, `u-system`, `u-emu`
function _controls:amx-userProfile {
  local namePrefix
  local _lookupType="${controller_profile#u-}"
  case "$1" in
    u-game) namePrefix="$relativeRomPath" ;;
    u-system) namePrefix="$system" ;;
    u-emu) namePrefix="$emulator" ;;
  esac
  local _profileName="${_lookupType}/${namePrefix}.gamecontroller.amgp"
  local _fullPath="$SAVES_ROOT_DIR"/controller-profiles/"$_profileName"
  if ! [ -e "$_fullPath" ]; then
    mkdir -p "$(dirname "$_fullPath")"
    cp "$_CONTROLLER_PROFILE_DIR"/EMPTY.gamecontroller.amgp "$_fullPath"
    _amx:restart --no-tray --profile "$_fullPath"
  fi
  echo "$_fullPath"
}

# @description
# This function will be called when the property `controller_profile` is set to any value other than `none`.  
# It will evaluate the property value and try to locate the actual profile file. However, the profile will 
# not be used as is, because we must ensure that the guide button works uniformly across all profiles.  
# Therefore, a temporary profile will be created, by selectively merging the located target with the `GUIDE` profile:
# 1. Overwrite the `GUIDE` button in all profile sets with the one from GUIDE
# 2. Overwrite (or add) the last set (index 8) from the GUIDE profile to the base profile. This set contains 
#    the control definitions needed to navigate the OS menu.  
# 3. The resulting file will be cached in `ES_CACHE_DIR/controller-profiles/`
# Before an existing file is re-created, a simple check based on modification times is done to make sure there is 
# unnecessary re-processing that would not have an effect.
# 
# The merging is not done in bash. It is done by `btc-config applyGuideProfile`.
function _controls:amx-configure {
  local _lookupPath

  case "$controller_profile" in
    u-*) _lookupPath="$(_controls:amx-userProfile "$controller_profile")" ;;
    int-*)
      _profileName="${_profileName:-${controller_profile#int-}.gamecontroller.amgp}"
      _lookupPath="$CONFIG_ROOT/controller-profiles/$_profileName"
      ;;
    deactivated)
      # enforce guide profile for basic OS level controller handling
	    _PRE_RUN_OPERATIONS+=("_fork _amx:restart --hidden --profile '$_GUIDE_PROFILE'")
      _POST_RUN_ACTIONS+=("_fork _amx:guideMode")
      return 0
  esac

  if [ -f "$_lookupPath" ]; then
    _PRE_RUN_OPERATIONS+=("_fork _amx:restart --hidden --profile '$_lookupPath'")
    _POST_RUN_ACTIONS+=("_fork _amx:guideMode")
    return 0
  fi
  
  return 1
}

# NOTE: AMX controller profile is incompatible with multiplayer for now
controller_profile=${controller_profile:-none}
if [ "$controller_profile" != "none" ]; then
  _logAndOut "Controller profile configured - disable/block controller inputs from game"
  _launchPrefix+=(firejail --noprofile --noinput)
  
  _controls:amx-configure \
    || _interface:errorAbort "Failed to configure profile for [controller_profile=$controller_profile]"
fi

# @endsection
