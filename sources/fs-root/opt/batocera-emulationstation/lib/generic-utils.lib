# SPDX-FileCopyrightText: 2025 Karsten Teichmann
#
# SPDX-License-Identifier: MIT

# @description
# Translate $1 with gettext, then replace placeholders in the string named after variable names given from $2 onwards.  
# Placeholders use the syntax `%%name%%`. Variables have to be visible to lc at the moment of calling.  
# It is also possible to directly pass strings instead of var names to lc (or a mixture of both).  
# Any argument which is not representing a valid variable name is assigned a positional number as name for the placeholders.  
# Multiple placeholders can occur in arbitrary order and are repeatable, resolution order is order of arguments `$2-$n`.
#
# **Note:**  
# `lc` by itself will **not** append a newline to the translated string.
#
# @stdout translated string
# @example
#   # examples show replacer logic, default gettext translation is omitted
#   file="/some/path"
#   lc "Translate this: %%file%%" file another_var
#   #output: "Translate this: /some/path"
#   # another_var will not have an effect, because it is not contained in the initial message
#   lc "Arg %%2%% is not compatible with file %%file%% in %%1%%" '/etc' file, '-x'
#   #output: "Arg -x is not compatible with file /some/path in /etc"
function lc {
  if [ -n "$NO_LC" ]; then
    local msg="$1"
  else
    local msg=$(gettext "$1")
  fi
  shift

  let _positionalString=0 || true
  while [ -n "$1" ]; do
    if [ -v "$1" ]; then
      msg="${msg//%%${1}%%/"${!1}"}"
    else
      let ++_positionalString
      msg="${msg//%%${_positionalString}%%/"$1"}"
    fi
    shift
  done
  echo -n "$msg"
}
export -f lc

# @description 
# Small wrapper around which to prevent any output and make syntax more readable. For use in ifs.
# @internal
function _hasBin {
  which "$1" &> /dev/null && return 0
  return 1
}
export -f _hasBin

# @description
# Helper to create modular script libraries. Can be used to only declare a function when it has not been declared.
# Modular script libraries are more compatible with tests by ShellTestRunner.  
# Exits with 0 if the given function exists, 1 if not. This makes it possible to simply prefix function declarations
# with `_hasFunc name || `. 
# 
# @example
#   # Single line, no doc. Single lines are not correctly recognized by shdoc.
#   _hasFunc 'name' || name() { 
#      some command
#   }
#   # multiline with a function documented by shdoc
#   _hasFunc 'funcName' || \
#   # some documentionation
#   # with multiple lines
#   function funcName { ... }
# 
# @internal
function _hasFunc {
  local t="$(type -t "$1" 2>/dev/null)"
  [ "$t" = "function" ]
}
export -f _hasFunc

# @description Remove double and trailing / slashes from the content of the variable given.  
# Contrary to realpath, which performs a similar canonicalization, this does not follow links 
# and it will also not convert relative to absolute paths.  
# Only the slashes will be deduplicated.
# @arg $1 variable name 
function _sanitizePath {
  local _extglob=($(shopt -p extglob || true))
  shopt -s extglob
  declare -n p="$1"
  p="${p//+(\/)/\/}"
  p="${p%+(/)}"
  "${_extglob[@]}" || true
}
export -f _sanitizePath

# @description join multiple strings into one, separated by the first argument given
# uses IFS internally, so it will only take the first character of $1 even when the string is longer
# @arg $1 character to use as separator
# @arg $2 ..$n strings to join
# @stdout $2[$1$3][$1$4][...]
function _join {
  local IFS="$1" && shift
  echo "$*"
}
export -f _join

# @description
# Split up a single string into an array while honoring quotes/elements with spaces.  
# Array will be declared as a global variable.  
# The input string can be omitted if an existing variable shell be converted from a string to an array.
# @arg $1 name of the array to create
# @arg $2 string to split. Optional, takes current content of "$1".
function _explode {
  local str="${2:-"${!1}"}"
  declare -ga "$1=($str)"
}
export -f _explode

# @description
# Check if an array contains a given value.  
# The check is done with the help of `grep -E` in the form of `^$searchString$`, thus only exact matches are found, 
# unless the search value itself is a regular expression.  
# **Note:**  
# If the search string contains special regex characters which should not evaluate as such, they have to be escaped.
# @arg $1 string array name
# @arg $2 string value to search
function _contains {
  local arr="${1}[@]"
  printf '%s\n' "${!arr}" | grep -E ^"$2"$ >/dev/null
}
export -f _contains

# @description
# Check if an assoc array contains a given value as key. Also works for keys with empty values.  
# The check is done with the help of `grep -E` in the form of `^$searchString$`, thus only exact matches are found, 
# unless the search value itself is a regular expression.  
# **Note:**  
# If the search string contains special regex characters which should not evaluate as such, they have to be escaped.
# @arg $1 string array name
# @arg $2 string key name to check
function _containsKey {
  declare -n arrName="$1"
  printf '%s\n' "${!arrName[@]}" | grep -E ^"$2"$ >/dev/null
}
export -f _containsKey

# @description Checks that given variable names exist and contain a value. Exit if otherwise.
function _requireVars {
  while [ -n "$1" ]; do
    declare -n required="$1"
    required="${required:?$1}"
    shift
  done
}
export -f _requireVars

# @description
# Execute a command starting at $2 and place the output in a variable named $1 when successful.  
# Return with the command's real exit code otherwise.
function _fetchCmdOutOrFail {
  [ "$#" -gt 1 ] || return 1
  local _varname="$1"
  shift
  # local declaration must be separate from assignment, because local itself changes $?
  local _value 
  _value=$("$@")
  local _code="$?"
  if [ "$_code" -gt 0 ]; then
    return "$_code"
  else
    declare -n result="$_varname"
    result="$_value"
  fi
}
export -f _fetchCmdOutOrFail

_hasFunc _checkOutdated || \
# @internal
# @description
# Generic check to see if a 'target' is older than the 'sources' it is produced from.  
# This is a generic function which can be used in any context where one file is generated from input 
# of at least one source file. In a lot of those situations, the input might not have changed at all, 
# so there is no need to run the full generation process of the target file.  
#  
# This function exists to test for this situation. It works by doing a rudimentary check of the 
# modification times of the arguments passed, with the first argument serving as the 'target/generated' file:
# - When $1 is the most recent, return 1 - calling code would not have to recreate the file in question.
# - When any of $2-$n is more recent, return 0 - recreation is necessary.
#
# @arg $1 file the target file
# @arg $2-n file source file(s)
function _checkOutdated {
  ## if the target does not even exist, it is 'outdated'
  [ -f "$1" ] || return 0
  local _targetFile="$1"
  local _targetDate=$(date -r "$1" '+%s')
  shift
  local _source
  local _sourceDate
  for _source in "$@"; do
    _sourceDate=$(date -r "$1" '+%s')
    [ "$_targetDate" -lt "$_sourceDate" ] && return 0
  done
  
  _logOnly "UPTODATE: $_targetFile"
  return 1
}
export -f _checkOutdated
