# ----- batch of generic helpers to get user input -----

function _confirm {
  read -p "${1:-Are you sure} [Y/n]? " -n 1 -r
  echo
  [[ $REPLY =~ ^[Yy]$ ]] && return 0
  return 1
}

# To be used by _askChoice. Encapsulates decision how and where to write the choices.
# For now, only tty is supported.
function _listChoice {
  echo "$@" > /dev/tty
}

function _askChoice {
  local choices=()
  let index=-1
  ! [ -t 0 ] && while read line; do
    [ -z "$line" ] && continue

    choices+=("$line")
    let index+=1
  done < /dev/stdin

  local addChoicesArg
  local prompt=""
  for c in "$@"; do
    if [ "$c" = "--choices" ]; then
      addChoicesArg="true"
    elif [ -n "$addChoicesArg" ]; then
      choices+=("$c")
      let index+=1
    else
      prompt="$prompt $c"
    fi
  done

  for (( i=0; i < "${#choices[@]}"; i++ )); do
    _listChoice "$i: ${choices[$i]}"
  done

  if [ "$index" = "-1" ]; then
    echo "Nothing to choose from was provided" >&2
    return 1
  fi

  if [ "$index" = "0" ]; then
    # autoselect first if there is only one
    echo -n "${choices[0]}"
    return 0
  fi

  let index+=1
  choices+=('ABORT')
  echo "$index: none of the above" > /dev/tty

  while true; do
    read -p "${prompt:- Please pick one of the choices above} (0-$index): " < /dev/tty
    if [[ "$REPLY" -ge 0 ]] && [[ "$REPLY" -le "$index" ]]; then
      break
    fi
  done
  echo -e "\nchosen: '${choices[$REPLY]}'" >&2
  echo -n "${choices[$REPLY]}"
}

# get a single line and keep as is
# $1: question to ask
# $2: default value
function _ask {
  echo '' >&2
  IFS='' read -i "$2" -e -p "$1 (default: '$2')"$'\n'": "
  if [ -z "$REPLY" ]; then
    echo -n "$2"
  else
    echo -n "$REPLY"
  fi
}