# SPDX-FileCopyrightText: 2026 Karsten Teichmann
#
# SPDX-License-Identifier: MIT

# do not allow this file to be sourced from outside of user-interface
[ "$(basename "${BASH_SOURCE[1]}")" != "user-interface.shl" ] && exit

# -----------
# @section Basic implementation

# @description
# TTY-style specific implementation of showing a list of choices and asking the user to pick one.  
# For exclusive use from within `ui:askChoice`.
# 
# Choices should be prepared as array with localized texts.
# @arg $1 string text to use
# @arg $2 ref name of an array to use
# @arg $3 int offset to start at (default 0)
# @stdout index number of selected choice
function ui#requestChoiceImpl
{
  local __question="${1:?missing prompt}"
  local -n __data="${2:?no choice array given}"
  local __offset="${3:-0}"
  
  local rpos
  for (( rpos=__offset; rpos < "${#__data[@]}"; rpos++ )); do
    echo "$rpos: ${__data[rpos]}"
  done
  if read -rp "=> ${__question} ($__offset-${#__data[@]}): " \
    && [ -n "$REPLY" ]; then
    echo "$REPLY"
  else
    return 1
  fi
}

# @description TTY-style implementation of yes/no utilizing `read`.
# @see [ui#requestConfirmationImpl](./backend-api.shl.md#uirequestConfirmationImpl)
function ui#requestConfirmationImpl
{
  local question confirmCharacters
  question="$1"
  # For console yes/no questions.
  confirmCharacters=$(lc '[Y/n]')
  local __prompt=$(lc '%%question%% %%confirmCharacters%%:' question confirmCharacters)
  
  read -rp "$__prompt"
  [[ "$REPLY" =~ $(locale yesexpr) ]]
}

# @description TTY-style implementation of asking for a directory.
# @see [ui#requestDirectoryImpl](./backend-api.shl.md#uirequestDirectoryImpl)
# TODO: add a note 'leave empty to cancel' to prompt message
function ui#requestDirectoryImpl
{
  local REPLY=""
  while ! REPLY=$("ui#verify_isDir" "$REPLY"); do
    read -rep "$1: " -i "${REPLY:-"${2}"}"
    [ -n "$REPLY" ] || return 1
  done
  echo -n "$REPLY"
}

# @description TTY-style implementation of asking for a file.  
# **Note:** This function uses `()` instead of `{}` for the function body
# because it heavily modifies the execution environment to configure `read`.
#
# @see [ui#requestFileImpl](./backend-api.shl.md#uirequestFileImpl)
# TODO: add a note 'leave empty to cancel' to prompt message
function ui#requestFileImpl
(
  # set up shell options and completion for read -E
  shopt -s nocasematch extglob no_empty_cmd_completion
  shopt -u progcomp_alias
  local __endings=$(_join \| "${@:3}")
  local __exclusion="!*.@(${__endings})"
  complete -r
  # set file name filter and disable any other bash completion
  complete -f -X "$__exclusion" -I -o plusdirs -o default
  local REPLY=""
  while ! REPLY=$("ui#verify_isFileType" "${__endings}" "$REPLY"); do
    read -rEp "$1: " -i "${REPLY:-"${2}"}"
    # trim trailing spaces which are added by tab completion
    REPLY="${REPLY%%[[:space:]]}"
    [ -n "$REPLY" ] || return 1
  done
  echo -n "$REPLY"
)

# @description TTY-style implementation of asking for arbitrary input with `read`.
# @see [ui#requestInputImpl](./backend-api.shl.md#uirequestInputImpl)
function ui#requestInputImpl
{
  local REPLY
  read -rep "$1"$'\n'": " -i "$2"
  REPLY="${REPLY%%[[:space:]]}"
  echo -n "$REPLY"
  [ -n "$REPLY" ] || return 1
}

# @endsection

# @section Form support

function ui#formAddField
{
  _printException "Forms are not supported on TTY" && exit 1
}

# @endsection
