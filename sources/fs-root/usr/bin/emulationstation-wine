#!/bin/bash

# SPDX-FileCopyrightText: 2025 Karsten Teichmann
#
# SPDX-License-Identifier: MIT

# @file /usr/bin/emulationstation-wine
# @description wrapper script for handling of wine, reading batocera config files and handling all game file types.

# @section Supported File Types
# This script supports the following file types out of the box
# - wine, pc: for directories
# - exe, msi, application
# - iso, nrg, mdf, img
# - (w)squashfs: Might impact performance
# - (w)tgz: Will be unpacked temporarily before game start. Not recommended for large games.
# @endsection

# @section Base implementation
# @internal
# @description
# `emulationstation-wine` is based on `launcher-base.lib`.  
# This section describes the api hook functions that `emulationstation-wine` implements.
# @see [launcher-base.lib](%%DOC_ROOT%%/dev/files/opt/batocera-emulationstation/lib/launcher-base.lib.md).

source "$FS_ROOT"/etc/batocera-paths.conf
source "$SH_LIB_DIR"/launcher-base.shl
source "$FS_ROOT"/opt/emulatorlauncher/lib/value-transformations.shl

dllOverrides=('winemenubuilder=d')
#winePaths=()

SUPPORTED_ACTIONS=(run play install mkAutorun autorun config tricks cmd)
ACTION_EXEC[play]="run"
ACTION_EXEC[autorun]="mkAutorun"

DESCRIPTION="
A re-implementation of batocera-wine which tries to keep the same base API, in addition to new capabilities.
Flags/actions that only exist for backwards-compatibility: 'play', '.wtgz', '.wsquashfs', '.pc'.

This script differentiates between 'library' [L] and 'user' [U] prefixes to support shared libraries.
- 'Library prefix' is the (potentially shared) game directory in the system folder itself.
- 'User prefix' is the effective WINEPREFIX when running the game.
  It will be created dynamically as an overlayfs structure.
  Changes done here only affect the user running the script, they will be part of the 'save' of the respective game.
  
Different actions target different folders by default, but some of them can be pointed to the other type by passing
'--user' or '--lib as first argument after <rom>.
"

ACTION_HELP[run]="run <rom>: path/to/rom[.wine|.pc|.(w)squashfs|.exe|.(w)tgz] - run directly [U]"
ACTION_HELP[play]="play <rom>: identical to 'run <rom>'"
ACTION_HELP[install]="install <rom>: path/to/rom[.exe|.(w)tgz|.msi|.iso] - create prefix in library and guide through installation setup [L]"
ACTION_HELP[mkAutorun]="mkAutorun <rom>: Helper to (re)create 'autorun.cmd'. [L]"
ACTION_HELP[autorun]="autorun <rom>: identical to 'mkAutorun <rom>'"
ACTION_HELP[config]="config <rom> [--user|--lib]: open winecfg [L]"
ACTION_HELP[tricks]="tricks <rom> [--user|--lib] trick1 [...]: install given tricks [L]"
ACTION_HELP[cmd]="cmd <rom> [--user|--lib] <command> <arg1> <...>: run arbitrary <command> (default is windows terminal) under wine [U]"

# configuration of supported file types
SUPPORTED_TYPES=( exe iso zip )
TYPE_GROUPS[wine]="dir"
TYPE_GROUPS[pc]="dir"

TYPE_GROUPS[squashfs]="fs"
TYPE_GROUPS[wsquashfs]="fs"

TYPE_GROUPS[nrg]="iso"
TYPE_GROUPS[img]="iso"
TYPE_GROUPS[mdf]="iso"

TYPE_GROUPS[tgz]="zip"
TYPE_GROUPS[wtgz]="zip"

TYPE_GROUPS[msi]="exe"
TYPE_GROUPS[application]="exe"

GAME_LAUNCH_PROPERTY_PREFIX="WINE_"

function handleType_exe {
  relativeRomPath="${relativeRomPath/windows_installers\//windows\/}"
}

# @description
# Hook into [launcher-base.lib:_setupPrefix](%%DOC_ROOT%%/dev/files/opt/batocera-emulationstation/lib/launcher-base.lib.md#_setupprefix).
# Convert the directory into a wine prefix if it isn't already:
# 1. use a cheap wine command to trigger creation of default prefix files
# 2. use winetricks to isolate the prefix from user home (no shared doc directories)
function _preparePrefixDir {
  local PREFIX="$1"
  [ -f "$PREFIX/system.reg" ] && return 0

  _wine "$PREFIX" start /? | _pipeDebugLog
  [ "${PIPESTATUS[0]}" = 0 ] || return 1

  WINEPREFIX="$PREFIX" winetricks -f -q isolate_home | _pipeDebugLog
  [ "${PIPESTATUS[0]}" = 0 ] || return 1
}

# @description
# When `dxvk` is enabled, a temporary overlay layer will be generated for it.
# Hooks into [launcher-base.lib:_initUserFromLib](%%DOC_ROOT%%/dev/files/opt/batocera-emulationstation/lib/launcher-base.lib.md#_initUserFromLib).
function _ofsLowerDirs {
  if _isTrue "$DXVK"; then
    _generateDxvkLayer "$1"
  fi
}

# @endsection

# @section Internal utilites
# @internal
# @description
# The following functions are private utilities used by actions and configuration hooks.

# @description
# Mounts `$WINE_DISC` if it was set. Tests several locations for the disc image:
# 1. Use directly - handles absolute paths and files relative to `pwd`
# 2. Relative to `DIR` from `autorun.cmd`
# 3. Relative to `$systemPath`. This is normally equivalent to `$ROMS_ROOT_DIR/$system`.  
#    However, users can define custom systems and paths and this accounts for that possibility.
# 4. Relative to `$ROMS_ROOT_DIR`
#
# This approach allows easy configuration and also portable game installations.
function _mountDisc {
  [ -n "$WINE_DISC" ] || return 0

  local candidates=(
    "$WINE_DISC"
    "$(absPath "$WINE_DIR" "$GAME_PREFIX")"/"$WINE_DISC"
    "$systemPath"/"$WINE_DISC"
    "$ROMS_ROOT_DIR"/"$WINE_DISC"
  )
  local candidate
  for candidate in "${candidates[@]}"; do
    ! [ -f "$candidate" ] && continue

    local _discPath="$(_mountFuse fuseiso "$candidate")"
    if [ -n "$_discPath" ]; then
      return 0
    else
      _interface:errorAbort "Failed to mount disc [$_discPath]"
    fi
  done
  _interface:errorAbort "[$WINE_DISC] not found at\n$(printf ' - %s' "${candidates[@]}")"
}

# @description
# Creates a temporary directory structure containing dxvk to be used as lowerdir in an overlay mount.  
# This function checks the architecture of the given prefix directory and generates a temporary directory using bindfs
# mounts of correct dxvk system installation folder.
#
# When `bindfs` pr `dxvk` are not installed, nothing will happen. However, it would still be possible to manually
# install DXVK into a prefix, e.g. with winetricks.  
# But then, emulationstation-wine then has no way of detecting whether `DXVK` is installed it also won't be possible
# to disable it from within ES.
#
# @arg $1 path wine prefix directory
#
# @requires aur:bindfs (optional)
# @requires aur:dxvk-bin (optional)
function _generateDxvkLayer {
  if ! _hasBin setup_dxvk; then
    _logAndOut "dxvk-bin(aur) not installed - can't install DXVK"
    return 1
  fi

  if ! _hasBin bindfs; then
    _logAndOut "bindfs(aur) not installed - can't create DXVK layer"
    return 1
  fi

  local wineArch=$(grep -Eho '#arch=win[[:digit:]]+' "$1"/* | tail -n 1 | cut -d'=' -f2)
  local layerDir="$TMP_DIR/dxvk"

  local mountTargets=("$TMP_DIR/dxvk/dosdevices/c:/windows/system32")
  local dllDir="/usr/share/dxvk/x32";
  if [ "$wineArch" = "win64" ]; then
    dllDir="/usr/share/dxvk/x64"
    mountTargets+=("$TMP_DIR/dxvk/dosdevices/c:/windows/syswow64")
  fi

  _logOnly "Generating DXVK layer from [$dllDir]..."
  for mp in "${mountTargets[@]}"; do
    mkdir -p "$mp"
    _mountFuse bindfs "$dllDir" "$mp" | _pipeDebugLog
  done

  for dll in "$dllDir"/*; do
    dllOverrides+=("${dll%.dll}=n")
  done

  OVERLAY_LAYERS+=("$layerDir")
}

#encapsulates calling the configured wine executable and setting up envs
function _wine {
  export LC_ALL="${WINE_LANG:-$LANG}"

  # TODO: implement proper search for umu gameid
  export GAMEID="${WINE_GAMEID:-btc-$gamename}"
  WINE_DIR="${WINE_DIR:-.}"

  cd "$GAME_PREFIX"/"$WINE_DIR" || \
    _interface:errorAbort "Not accessible: $GAME_PREFIX/$WINE_DIR"

  if [ -n "$WINE_ENV" ]; then
    _explode WINE_ENV
    export "${WINE_ENV[@]}"
  fi

  WINEDLLOVERRIDES=$(_join , "$WINEDLLOVERRIDES" "${dllOverrides[@]}")
  export WINEDLLOVERRIDES

  _logAndOut -e "\n ***** Running [$@] *****"
  wineBin="${WINE_BINARY:-wine}"
  WINEPREFIX="${WINEPREFIX:-$GAME_PREFIX}"
  export WINEPREFIX

  "$wineBin" "$@" | _pipeDebugLog
  return "${PIPESTATUS[0]}"
}

#search case-insensitive for windows binary relative to $1
function _findExes {
  (
    cd "$1"
    find -L . -mount \
      \( -path '*/z:/*' -prune -o \
      -path '*/windows/*' -prune -o \
      -path '*/users/*' -prune \
      \) -o \( \
      -iname '*.exe' -o \
      -iname '*.msi' -o \
      -iname '*.application' \
      \) -print 2>/dev/null
  )
}

# @endsection

# @section Supported Actions
# @description The following actions can be passed to emulationstation-wine.
# All of these functions take the same argument line format:<br>
# `emulationstation-wine <function-name> <path/to/rom> [-cfg path/to/emulatorlauncher/config] [-- args for real executable]"`
# * `-cfg` is optional and usually an internal implementation detail between `emulatorlauncher` and and this script
# * `--` and anything following it is optional and will be passed to the real `*.exe` that will be launched at the end
#
# However, these functions run against different targets (=WINEPREFIX), as explained in the section about prefixes.

# @description The main function: Start a game.  
# Targes user prefix, derived from the given library rom path.
function run {
  _userPrefix
  _mountDisc
  _wine "${WINE_CMD[@]}" "${addArgs[@]}"
}

function explore {
#lib, u
#empty for now, start explorer or something
echo
}

function import {
echo
}

# @description Install a game. Asks a few questions to guide and improve automatic installation.
# 1. Creates a new library prefix from another library rom.
# 2. Installation source must be file/directory from the windows/windows_installers systems
# 3. Can handle setup exes, zip files, isos and plain copy
function install {
  source "$SH_LIB_DIR"/user-interface.shl
  LIB_DIR="$(dirname "$LIB_DIR")/${gamename}.wine"
  clear
  while true; do
    relativeRomPath="$(realpath -s -m --relative-to="$ROMS_ROOT_DIR" "$LIB_DIR")"
    _question="Where should the game be installed (path relative to $ROMS_ROOT_DIR)?"$'\n'
    relativeRomPath="$(_ask "$_question" "$relativeRomPath")"
    _installDir="$ROMS_ROOT_DIR/$relativeRomPath"
    if [[ "$_installDir" != *.wine ]]; then
      _logAndOut "[$_installDir] does not end with .wine"
    elif [ -e "$_installDir" ] && [ -n "$(ls "$_installDir")" ]; then
      _logAndOut 'Directory exists and is not empty. Please select another or abort+delete first.'
    else
      LIB_DIR="$_installDir"
      unset _installDir && break
    fi
  done
  _libraryPrefix

  case "$_fileEnding" in
    exe|msi|application)
      _installerBinary="$absRomPath"
      ;;
    zip|iso|fs)
      local copyOption="NONE - copy files to installation directory"
      _installerBinary=$(_findExes "$_templatePrefix" \
        | _askChoice "Which is the installer executable?" \
        --choices "$copyOption")
      if [ "$copyOption" = "$_installerBinary" ]; then
        _installerBinary="cp"
      else
        _installerBinary="$_templatePrefix/$_installerBinary"
      fi
      ;;
    *)
      _logAndOut "$_fileEnding is not a valid type for installation"
      exit 1
      ;;
  esac

  local returnCode="1"
  if [ "cp" = "$_installerBinary" ]; then
    cp -r "$_templatePrefix"/* "$LIB_DIR"
    returnCode="$?"
  else
    (
      WINE_CMD=("_wine" "start" "/wait" "/unix" "$_installerBinary" "${addArgs[@]}")
      cd "$WINEPREFIX"
      "${WINE_CMD[@]}" || exit 1
      wineserver -k || exit 1
    )
    returnCode="$?"
  fi

  [ "$returnCode" != "0" ] && _logAndOut 'Installation failed' && exit 1

  mkAutorun
}

# @description This is a guided utility that can be used to create `autorun.cmd` files for wine applications.  
# Will automatically be started at the end of a new installation, but can also be triggered manually later on.
# Targets library prefixes. 
#
# If the `autorun.cmd` file shall be different for a user, it has to be patched manually in the user save dir.  
# **Note:** When changed manually for a user, changes in the file within the library prefix will NOT propagate to that user anymore.
#
# **Format and supported properties:**  
# ```ini
# # Required: the actual launch command, windows-style syntax
# # Arguments using blanks must be quoted 
# CMD=some.exe /arg1
# # Required: Working directory
# # Linux path relative to `WINEPREFIX`, usually starts with `drive_c` or `dosdevices/c:`
# DIR=drive_c/game
# # Optional: Locale to use, linux style (mapped by wine)
# LANG=en_US
# # Optional: Declare more environment variables to pass to the game. Supports quoting with `"`
# # No blanks around `=` signs (will be interpreted as an empty value). 
# ENV=SOME_VAR="with blank" VAR2=false
# # Optional: Some games require a disc to run, even after installation. 
# # The disc can be supplied in any supported image format.
# # Linux path, can be absolute or relative to either DIR, the real system path (when there is no common rom dir) or $ROMS_ROOT_DIR
# DISC=path/to/image
# ```
function mkAutorun {
  source "$SH_LIB_DIR"/user-interface.shl
  _libraryPrefix
  _mountDisc

  local _autorunLines _gameExe _exeRel _workdir _argLine _lang _envs
  while true; do
    clear
    echo -e 'Installation will now ask a few questions to complete the necessary configuration...\n' >&2
    _autorunLines=()
    echo 'Searching for executables within WINEPREFIX while ignoring nested mount points...' >&2
    _gameExe=$(_findExes "$WINEPREFIX/dosdevices" | _askChoice "Which is the game executable?")
    if [ "$_gameExe" != "ABORT" ]; then
      _exeRel="$(realpath --relative-to="$WINEPREFIX" "$WINEPREFIX/dosdevices/$_gameExe")"
    else
      _gameExe="$WINEPREFIX"
      while ! [ -f "$_gameExe" ]; do
        _gameExe=$(_ask "Manually specify the executable (resolved relative to $(pwd))" "$WINEPREFIX")
      done
      _exeRel="$(realpath --relative-to="$WINEPREFIX" "$_gameExe")"
    fi
    _workdir=$(cd "$WINEPREFIX" && _ask "Work dir (relative to $WINEPREFIX)" "$(dirname "$_exeRel")")
    _workdir=$(cd "$WINEPREFIX" && realpath --relative-to="$WINEPREFIX" "$_workdir")

    _argLine=("$(realpath --relative-to="$WINEPREFIX/$_workdir" "$WINEPREFIX/$_exeRel")")
    _argLine+=($(_ask 'Additional launch arguments (leave blank if none)'))
    _autorunLines+=("CMD='${_argLine[@]}'")

    _autorunLines+=("DIR=$_workdir")

    _lang=$(_ask "language (use system default if empty)")
    if [ -n "$_lang" ]; then
      _autorunLines+=("LANG=$_lang")
    else
      _autorunLines+=('#LANG=en_US')
    fi

    _envs=$(_ask 'additional env vars:')
    if [ -n "$_envs" ]; then
      _autorunLines+=("ENV=$_envs")
    else
      _autorunLines+=("#ENV=VAR1='something' VAR2=''")
    fi

    if [ "$_fileEnding" = "iso" ]; then
      if _confirm "Is the disc required to run the game?"; then
        DISC_PATH=$(realpath --relative-to="$ROMS_ROOT_DIR" "$_target")
        _autorunLines+=("DISC=$DISC_PATH")
      fi
    elif _confirm $'\n'"Does the game require a disk to run"; then
      # TODO: implement
      echo 'not implemented yet' >&2
    fi

    echo $'\n'"Resulting autorun.cmd in $WINEPREFIX:" >&2
    echo '----------' >&2
    printf '%s\n' "${_autorunLines[@]}" >&2
    echo '----------' >&2
    if _confirm $'\n'"Correct?"; then
      break
    fi
  done

  printf '%s\n' "${_autorunLines[@]}" > "$WINEPREFIX/autorun.cmd"
}

#winecfg for the prefix, if possible
function config {
  _dynamicSelectPrefix --lib
  _mountDisc
  _wine winecfg
}

#manual tricks. shouldnt be needed for most stuff that umu handles.
function tricks {
  _dynamicSelectPrefix --lib
  _mountDisc
  WINEPREFIX="$GAME_PREFIX" winetricks -f -q "${ARGS[@]}"
}

#run arbitrary command within the wineprefix associated with the game/user
function cmd {
  _dynamicSelectPrefix --user
  _mountDisc
  if [ "${#ARGS[@]}" = 0 ]; then
    _wine cmd
  else
    _wine "${ARGS[@]}"
  fi
}

export WINEDLLOVERRIDES="${WINEDLLOVERRIDES};winemenubuilder.exe=d"
main
