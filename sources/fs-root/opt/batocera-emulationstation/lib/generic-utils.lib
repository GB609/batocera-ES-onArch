# @description 
# Small wrapper around which to prevent any output and make syntax more readable. For use in ifs.
# @internal
function _hasBin {
  which "$1" &> /dev/null && return 0
  return 1
}
export -f _hasBin

# @description
# Helper to create modular script libraries. Can be used to only declare a function when it has not been declared.
# Modular script libraries are more compatible with tests by ShellTestRunner.  
# Exits with 0 if the given function exists, 1 if not. This makes it possible to simply prefix function declarations
# with `_hasFunc name || `. 
# 
# @example
#   # Single line, no doc. Single lines are not correctly recognized by shdoc.
#   _hasFunc 'name' || name() { 
#      some command
#   }
#   # multiline with a function documented by shdoc
#   _hasFunc 'funcName' || \
#   # some documentionation
#   # with multiple lines
#   function funcName { ... }
# 
# @internal
function _hasFunc {
  local t="$(type -t "$1" 2>/dev/null)"
  [ "$t" = "function" ]
}
export -f _hasFunc

# @description join multiple strings into one, separated by the first argument given
# uses IFS internally, so it will only take the first character of $1 even when the string is longer
# @arg $1 character to use as separator
# @arg $2 ..$n strings to join
# @stdout $2[$1$3][$1$4][...]
function _join {
  local IFS="$1" && shift
  echo "$*"
}
export -f _join

# @description
# Split up a single string into an array while honoring quotes/elements with spaces.  
# Array will be declared as a global variable.
# @arg $1 name of the array to create
# @arg $2 string to split
function _explode {
  declare -ga "$1=($2)"
}
export -f _explode

_hasFunc _checkOutdated || \
# @internal
# @description
# Generic check to see if a 'target' is older than the 'sources' it is produced from.  
# This is a generic function which can be used in any context where one file is generated from input 
# of at least one source file. In a lot of those situations, the input might not have changed at all, 
# so there is no need to run the full generation process of the target file.  
#  
# This function exists to test for this situation. It works by doing a rudimentary check of the 
# modification times of the arguments passed, with the first argument serving as the 'target/generated' file:
# - When $1 is the most recent, return 1 - calling code would not have to recreate the file in question.
# - When any of $2-$n is more recent, return 0 - recreation is necessary.
#
# @arg $1 file the target file
# @arg $2-n file source file(s)
function _checkOutdated {
  ## if the target does not even exist, it is 'outdated'
  [ -f "$1" ] || return 0
  local _targetFile="$1"
  local _targetDate=$(date -r "$1" '+%s')
  shift
  local _source
  local _sourceDate
  for _source in "$@"; do
    _sourceDate=$(date -r "$1" '+%s')
    [ "$_targetDate" -lt "$_sourceDate" ] && return 0
  done
  
  _logOnly "UPTODATE: $_targetFile"
  return 1
}
export -f _checkOutdated