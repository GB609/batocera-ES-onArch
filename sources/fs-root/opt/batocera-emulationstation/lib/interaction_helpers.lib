# SPDX-FileCopyrightText: 2025 Karsten Teichmann
#
# SPDX-License-Identifier: MIT

# @file
# This file contains a generic set of utility function that can be used for interaction with the user.  
# It automatically detects if used from a process connected to a terminal or not. If there is no terminal,
# message dialogs will be displayed.  
# Even if not connected to a terminal, console-based implementations will be used when there is no `$DISPLAY`

if tty -s || [ -z "$DISPLAY" ]; then
  _IAH_STYLE="TTY"

  function _interface:_consoleChoices {
    cat < /dev/stdin >/dev/tty
    read -p "=> ${prompt:-"$defPrompt above"} (0-$index): " < /dev/tty
    echo "$REPLY"  
  }
else
  _IAH_STYLE="UI"
  function _interface:baseDialog {
    zenity --modal --title="" "$@"
  }

  function _interface:_uiChoices {
    _interface:baseDialog \
      "--text=$1" --list --radiolist \
      --column="selection" --column="KEY" --column="Text" \
      --hide-column=2 --hide-header \
      --print-column=2
  }
fi

# @description simple helper that can be used to determine if a graphical dialog shall be shown
function _useUI { [ "$_IAH_STYLE" = "UI" ]; }

function _confirm {
  local _message="${1:-Are you sure?}"
 
  if _useUI; then
    _interface:baseDialog --question --text="$_message" --ok-label="Yes" --cancel-label="No" --default-cancel
    return "$?"
  fi
  
  read -p "$_message [Y/n]? " -n 1 -r
  echo
  [[ $REPLY =~ ^[Yy]$ ]] && return 0
  return 1
}

# @description
# To be used by _askChoice. Encapsulates decision how and where to write the choices.
# For now, only tty is supported.
# $1 index
# $2 text
function _listChoice {
  if _useUI; then
    printf '%s\n' FALSE "$1" "$2"
  else 
    echo "$1: $2"
  fi
}

function _askChoice {
  local choices=()
  local textOverrides=()
  let index=-1
  ! [ -t 0 ] && while read line; do
    [ -z "$line" ] && continue

    choices+=("$line")
    let index+=1
  done < /dev/stdin

  local addChoicesArg
  local prompt=""
  for c in "$@"; do
    if [ "$c" = "--choices" ]; then
      addChoicesArg="true"
    elif [ -n "$addChoicesArg" ]; then
      choices+=("$c")
      let index+=1
    else
      prompt="$prompt $c"
    fi
  done

  # coding error by developer 
  if [ "$index" = "-1" ]; then
    _logAndOut "Nothing to choose from was provided"
    return 1
  fi

  if [ "$index" = "0" ]; then
    # autoselect first if there is only one
    echo -n "${choices[0]}"
    return 0
  fi
  
  let index+=1
  choices+=('ABORT')
  textOverrides[$index]="none of the above"
  
  echo "choices are: [${choices[@]}]" >&2
  
  defPrompt="${prompt:-Please pick one of the choices}"
  _command=()
  if _useUI; then
    _command=(_interface:_uiChoices)
    _command+=("${prompt:-"$defPrompt"}")
  else
    _command=('_interface:_consoleChoices')
  fi
  
  while true; do
    RESULT=$(
      for (( i=0; i < "${#choices[@]}"; i++ )); do 
        _text="${textOverrides[$i]}"
        _listChoice "$i" "${_text:-${choices[$i]}}"
      done | "${_command[@]}"
    )
    
    # select abort when empty
    RESULT="${RESULT:-$index}"
    
    if [[ "$RESULT" -ge 0 ]] && [[ "$RESULT" -le "$index" ]]; then
      break
    fi
  done

  _logAndOut "\nchosen: '${choices[$RESULT]}'"
  echo -n "${choices[$RESULT]}"
}

# @description Get a single line from the user and keep as it is.
# $1: question to ask
# $2: default value
function _ask {
  local _question="$1 (default: '$2')"
  if _useUI; then
    REPLY="$(_interface:baseDialog --entry --text="$_question" --entry-text="$2")"
  else
    echo '' >&2
    IFS='' read -i "$2" -e -p "$_question"$'\n'": "
  fi

  echo -n "${REPLY:-"$2"}"
}

function _interface:askDirectory {
  echo tbd
}

function _interface:askFile {
  echo tbd
}

# @description Print and log a message, exit shell
function _interface:errorAbort {
  if _useUI; then
    _logOnly "ERROR: $@"
    _interface:baseDialog --error "--text=$(printf '%s ' "$@")"
  else
    # reset current status to prevent undesired executions of -e/-E through status propagation of log functions
    # not an issue because this is a controlled shutdown using regular `exit 1`
    true && _logAndOut "ERROR: $@"
  fi
  exit 1
}
