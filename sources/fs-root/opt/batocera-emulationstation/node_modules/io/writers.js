// SPDX-FileCopyrightText: 2025 Karsten Teichmann
//
// SPDX-License-Identifier: MIT

/**
 * @file Utilities to write object graphs to files or streams like stdout.
 * @description 
 * There are several config files (and types) throughout the system that `btc-config` needs to generate or maintain.  
 * Additionally, there are situations where a list of properties has to be printed, optionally in different formats.  
 * All of this is encapulated in this module. It supports several output formats and is fully transparent about the
 * target to write to. In addition, the all a user has to know is the format name, the outside API is identical for
 * all of the writers.
 * 
 * **Currently supported:**
 * - yaml (basic subset)
 * - json
 * - xml
 * - conf (batocera-specific format)
 * - sh (shell code)
 * - features (es_features.cfg)
 * - systems (es_systems.cfg)
 * - settings (es_settings.cfg)
 * - plain (just stringifies whatever value or value[] is passed in)
 *  
 * To use a writer, use `requiredModule[formatName].write(dictionary, fileOrStream, options)`. 
 * 
 * **Implementation details:**
 * 1. All known writers must be classes extending the class `{Writer}` which sets up the generic API.
 *    The generic API mostly consists of a static method `write` and an instance method `write`.
 * 2. Subclasses need only implement/overwrite `writeDict`.
 * 3. No subclass must define a method named `write`, neither static nor instance-specific. This is core writer api.
 * 4. `Writer.write()` is a static method that works as a writer instance factory. It detects the class type
 *    it was invoked from and creates a new instance of that. Then passes the data and options to `writeDict`
 *    after setting up the output channel.
 * 5. Subclass instances must use `this.write(string|string[])` to generate output.  
 *    There is no need for further buffering. This is handled generically.
 */

const fs = require('node:fs');
const log = require('logger').get();
const { dirname, extname } = require('node:path');
const { deepImplode, deepKeys, HierarchicKey, isEmpty } = require('utils/data');
const { PropValue } = require('io/parsers');

function asString(data) {
  if (Array.isArray(data)) { return data.join('\n') }
  else { return data.valueOf().toString() }
}

function whitespace(numSpaces) { return ''.padEnd(numSpaces, ' ') }
function isEmptyDict(object) { return typeof object == "object" && isEmpty(object) }
function xmlEncode(data = null, visited = []) {
  if (visited.includes(data)) { return data }

  if (data == null) { return null; }
  if (typeof data == "string") {
    return data.replace(/[<>&"']/g, function(c) {
      switch (c) {
        case '<': return '&lt;';
        case '>': return '&gt;';
        case '&': return '&amp;';
        case "'": return '&apos;';
        case '"': return '&quot;';
      }
    });
  } else if (Array.isArray(data)) {
    visited.push(data);
    for (let i = 0; i < data.length; i++) {
      data[i] = xmlEncode(data[i], visited);
    }
  } else if (typeof data == "object") {
    visited.push(data);
    Object.keys(data).forEach(k => data[k] = xmlEncode(data[k], visited))
  }

  return data;
}

/**
 * Assign given default to property with the given name if it is not defined.
 * Includes special treatment for PropValue instances.
 */
function setDefault(object, prop, defaultValue) {
  if (object[prop] instanceof PropValue && isEmpty(object[prop].value)) {
    object[prop].value = defaultValue;
  } else if (isEmpty(object[prop])) {
    object[prop] = defaultValue;
  }
}

/**
 * This class is the core API and generic part of all writer implementations.  
 * Every new writer MUST extends this and follow the contract specified above.
 */
class Writer {
  //5kb mini buffer to better handle writes
  static #MAX_CHUNK_SIZE = 5 * 1024;
  chunk = '';

  /**
   * The constructor sets up the output. Subclassed must not provide a contructor.
   */
  constructor(target) {
    if (Number.isInteger(target) || Number.isInteger(target.fd)) {
      this.handle = target.fd || target;
      this.filename = "output-stream";
    } else if (typeof target.valueOf() == 'string') {
      fs.mkdirSync(dirname(target), { recursive: true })
      this.handle = fs.openSync(target, 'w');
      this.selfOpened = true;
      this.filename = target;
    } else {
      throw 'Not a valid file descriptor/name: ' + target;
    }
  }

  /**
   * This method is the main entry to the writer API and must not be redeclared on any subclass.  
   * It will handle the full logic flow needed to write to any output:
   * 1. Create a writer instance
   * 2. Set up the output channel
   * 3. Perform the actual writing by calling `writerInstance.writeDict()`
   * 4. Close the output channel and return
   *   
   * **About `options`**
   * `options` are a way to control the behaviour of writers. It is a simple dictionary.  
   * Most options are writer-specific. The generic entry method supports 2 options at the moment:
   * 1. `verbose=boolean`: Add a log statement when the actual writing using `writeDict` begins.
   * 2. `createRootKeysDictFile=/path/to/file`:
   *     This generates a 'summary' file at the specified location which contains only the root keys of `dict`.  
   *     This option is mostly used for logic simplification during config import and for detection of supported systems.
   * 3.  `keyPrefix=string`: Prepends the given value to all root keys.
   *   
   * Some options are supported by multiple writers:
   * - `options.printSource=boolean`: 
   *   For debugging when `dict` is a merge result which should be written in a format supporting comments.
   *   Every property value written will be accompanied by a comment stating which file it came from.
   * - `options.comment=string`: Adds the given text as comment to the head of the file if supported.
   */
  static write(dict, targetFile, options = {}) {
    let actualWriter = new this(targetFile);
    log.debug(`Using [${actualWriter.constructor.name}] for file [${actualWriter.filename}] with options:`, options);
    try {
      if (options.verbose) { log.userOnly(`Writing ${targetFile}`) }
      if (typeof options.keyPrefix == "string") {
        let prefix = options.keyPrefix;
        let remapped = Object.create(Object.getPrototypeOf(dict));
        for (let k in dict) {
          remapped[prefix + k] = dict[k];
        }
        dict = remapped;
      }
      actualWriter.writeDict(dict, options);
      //optionally create a generated summary cache file of the root keys
      //useful as a filter for merges etc
      if (typeof options.createRootKeysDictFile == "string") {
        let keyTable = {};
        Object.keys(dict).forEach(k => keyTable[k] = {});
        let fileType = extname(options.createRootKeysDictFile).substring(1);
        module.exports[fileType].write(keyTable, options.createRootKeysDictFile, { verbose: options.verbose || false });
      }
    } finally {
      actualWriter.close();
    }
  }

  write(data) {
    data = asString(data);
    if (data.length == 0) { return }
    this.chunk += data;
    if (this.chunk.length >= Writer.#MAX_CHUNK_SIZE) {
      fs.writeFileSync(this.handle, this.chunk, { flag: 'a' });
      this.chunk = '';
    }
  }

  flush() {
    if (this.chunk.length > 0) {
      fs.writeFileSync(this.handle, this.chunk, { flag: 'a' })
      this.chunk = '';
    }
  }

  close() {
    this.flush();
    if (this.selfOpened == true) { fs.closeSync(this.handle) }
  }
}

/**
 * Simple wrapper of the writer API that does not produce output in a predefined format.  
 * It just outputs the string value of whatever is passed in. No support for any further options,
 * aside from those handled by the generic {Writer}. But these do not make much sense to use here.
 */
class PlainWriter extends Writer {
  writeDict(dict) { this.write(asString(dict)) }
}

/**
 * Writes the given dict as batocera-style `.conf` file, like `batocera.conf`.
 * 1. Handles game specific properties
 * 2. Handles folder-specific properties
 * 3. Nested `dict` structures will be flattened first
 *   
 * **Supported options:**
 * - `comment=string`: no comment when not given
 * - `printSource=boolean`: default false
 */
class ConfWriter extends Writer {
  writeDict(dict, options) {
    let imploded = deepImplode(dict);
    let keysSorted = [...Object.keys(imploded)].sort();

    if (options.comment) { this.write('# ' + options.comment.split('\n').join('\n# ') + '\n\n') }
    for (let key of keysSorted) {
      let val = imploded[key];
      setDefault(imploded, key, null);
      if (isEmptyDict(val) || val.valueOf() == null) { continue }
      if (options.printSource) { this.write(`#${val.source}\n`) }
      this.write(`${key}=${val}\n`);
    }
  }
}

/**
 * Writes data to a json file.
 * - no support for any options
 * - file will be formatted in a human-readable way
 */
class JsonWriter extends Writer {
  writeDict(dict, options) { this.write(JSON.stringify(dict, null, 2)) }
}

class YamlWriter extends Writer {
  static KV_LINE = /^([ ]*)"(.*)":(.*),{0,1}/;
  writeDict(dict, options) {
    let jsonString = JSON.stringify(dict, null, 2);
    jsonString = jsonString.split(/,?\n/)
      .map(_ => _.substring(2).replaceAll(/\{|\},?/g, '').replace(/\],$/, ']'))
      .filter(_ => _.trim().length > 0)
      .map(_ => {
        let parsed = YamlWriter.KV_LINE.exec(_);
        if (parsed == null) { return _ }
        return `${parsed[1]}${parsed[2]}: ${parsed[3].trim()}`;
      })
      .map(_ => _.trimEnd());
    this.write(jsonString);
  }
}

/**
 * Write object graphs to as structured XML, based on the definitions from `xmlToDict`.  
 *   
 * Emulationstation uses XML for some config files. Most of them have the file ending `*.cfg`.  
 * And they have in common that they don't share any tags or structure, they are specific, well known and named files,
 * serving different purposes. There exist dedicated writes for most of them because they are so different.  
 * 
 * **Supported options:**
 * - `comment=string`: no comment when not given
 */
class XmlWriter extends Writer {
  writeDict(dict, options = {}) {
    this.write('<?xml version="1.0" encoding="UTF-8"?>\n');
    if (options.comment) { this.write(`<!-- ${options.comment} -->\n`) }
    this.writeSubDict(null, dict);
  }

  writeSubDict(key, dict, nesting = 0) {
    if (Array.isArray(dict) && key != null) {
      dict.forEach(entry => this.writeSubDict(key, entry, nesting))
      return
    } else if (dict == null) {
      dict = { '#text': '' }
    } else if (typeof dict.valueOf() != "object") {
      dict = { '#text': dict }
    }

    let keys = Object.keys(dict);
    let attribs = keys.filter(_ => _.startsWith('@'));
    let subElements = keys.filter(_ => !attribs.includes(_) && _ != '#text');
    let textContent = xmlEncode(dict['#text']) || (subElements.length > 0 ? '\n' : '');
    let noContent = textContent.length == 0;

    if (key == null) {
      //synthesize a pseudo-root when the top-level has multiple sub elements
      if (nesting == 0 && subElements.length > 1) { return this.writeSubDict('NO-ROOT', dict) }
      return subElements.forEach(sub => { this.writeSubDict(sub, dict[sub], nesting + (key == null ? 0 : 2)) });
    }

    let attributeString = attribs.map(a => `${a.substring(1)}="${xmlEncode(dict[a].valueOf())}"`);
    if (attributeString.length > 0) { attributeString = ' ' + attributeString.join(' ') }
    this.write(`${whitespace(nesting)}<${key}${attributeString}`);

    if (noContent) { return this.write('/>\n') }
    else { this.write(`>${textContent}`) }

    subElements.forEach(sub => { this.writeSubDict(sub, dict[sub], nesting + (key == null ? 0 : 2)) })
    this.write(`${whitespace(subElements.length > 0 ? nesting : 0)}</${key}>\n`);
  }
}

/**
 * Write object graphs as sourceable shell code.  
 *   
 * **Supported options:**
 * - `declareCommand=string`: shell command used to declare variables.  
 *   Can be any visible/exported function from the calling context.
 * - `printSource=boolean`: default false
 * - `stripPrefix=int`: default 0. Remove (up to) n levels of HierarchicKey segments from each property path.  
 *   Applies a bit of logic to ensure the resulting top-level could would not be an integer, but an actual word.  
 *   Example: stripPrefix=2, `a.b.c=5 => c=5`, `a.b[3]=true => b[3]="true"` (both have 3 segments).
 */
class ShellWriter extends Writer {
  static quoteNestedApos(value) { return String(value).replace(/'/g, "'\\''"); }

  writeDict(dict, options) {
    let resultKeyLevelStart = options.stripPrefix || 0;
    let keys = deepKeys(dict);
    let reorganized = {};
    let declaredProps = {};

    let toplevelPrefix = typeof options.keyPrefix == "string" ? options.keyPrefix : "";
    for (let k of keys) {
      let adjustedKey = [0];
      let reducedStart = Math.min(resultKeyLevelStart, k.length);
      // for shell, the top-level keys should not be numbers because naming variables after them is problematic
      // try to reduce the stripping iteratively until a string key is encountered
      while (reducedStart >= 0 && Number(adjustedKey[0]) == adjustedKey[0].toString()) {
        adjustedKey = k.slice(Math.min(reducedStart--, k.length - 1))
      }
      // when even the top-level is a number, make an artifical string with prefix out of it
      if (Number(adjustedKey[0]) == adjustedKey[0].toString()) { adjustedKey = ['idx' + adjustedKey[0]] }

      adjustedKey = new HierarchicKey(adjustedKey.shift(), ...(adjustedKey.length > 0 ? [adjustedKey.join('_')] : []));
      if (typeof declaredProps[adjustedKey] != "undefined") {
        log.warn('Property name collision on sublevel after prefix ()%s stripping (overriding previous):\n\t%s\n\t%s',
          resultKeyLevelStart, declaredProps[adjustedKey], k);
      }
      if (!String(adjustedKey).startsWith(toplevelPrefix)) {
        adjustedKey[0] = toplevelPrefix + adjustedKey[0];
      }
      declaredProps[adjustedKey] = k;
      adjustedKey.set(reorganized, k.get(dict));
    }

    let dcl = options.declareCommand || 'declare';
    Object.entries(reorganized).flatMap(entry => {
      let k = entry[0];
      let v = entry[1];
      if (typeof v.valueOf() == "object") {
        let entries = [[`${dcl} -A ${k}`]];
        let commonSource = v.source;
        for (let [sk, sv] of Object.entries(v)) {
          entries.push([`${k}['${sk}']='${ShellWriter.quoteNestedApos(sv)}'`, sv.source || commonSource]);
        }
        return entries;
      } else {
        return [[`${dcl} ${k}='${ShellWriter.quoteNestedApos(v)}'`, v.source]]
      }
    }).forEach(line => {
      if (options.printSource) { this.write(`# ${line[1] || 'source file unknown'}\n`) }
      this.write(`${line[0]}\n`)
    });
  }
}

/**
 * This writer implementation is meant to specifically generate the file `es_settings.cfg`.  
 * `EmulationStation` uses several `*.cfg` files, but they don't share a common structure in terms of properties.
 */
class EsSettingsWriter extends XmlWriter {
  static GAME_SPECIFIC = /^[\-\w]+\.game\[/;
  writeDict(dict, options) {
    let imploded = deepImplode(dict);
    let docRoot = { config: {} }
    Object.entries(imploded).forEach(([key, value]) => {
      let tagName;

      //btc-config internal property resolution transforms game-specific properties into the form.
      //system.game["game-name"].... for easier recognition and merge. This must be reverted before writing here.
      if (EsSettingsWriter.GAME_SPECIFIC.test(key)) { key = key.replace('.game[', '[') }

      switch (typeof value.valueOf()) {
        case 'boolean':
          tagName = 'bool';
          break;
        case 'number':
          value = Number(value)
          if (Number.isInteger(value)) { tagName = 'int'; break; }
          else if (Number.isFinite(value)) { tagName = 'float'; break; }
        default:
          tagName = 'string';
      }

      docRoot.config[tagName] ||= []
      docRoot.config[tagName].push({
        '@name': key,
        '@value': value
      });
    });

    super.writeDict(docRoot, options);
  }
}

class EsSystemsWriter extends Writer {
  static #DEFAULT_LAUNCH_COMMAND = "emulatorlauncher %CONTROLLERSCONFIG% -system %SYSTEM% -rom %ROM% -gameinfoxml %GAMEINFOXML% -systemname %SYSTEMNAME%";
  static #ATTRIBUTE_HANDLER = new class {
    key(system) { return [`<name>${system.key}</name>`] }
    name(system) { return [`<fullname>${system.name}</fullname>`] }
    extensions(system) { return [`<extension>${(system.extensions || []).map(e => '.' + e).join(' ')}</extension>`] }
    emulators(system) {
      return [
        '<emulators>',
        ...EsSystemsWriter.#ATTRIBUTE_HANDLER.emulatorsToXml(system.emulators).map(_ => whitespace(2) + _),
        '</emulators>'
      ]
    }
    emulatorsToXml(emulators) {
      let lines = [];
      for (let [key, value] of Object.entries(emulators)) {
        lines.push(`<emulator name="${key}"><cores>`);
        Object.keys(value).forEach(core => {
          lines.push(`${whitespace(2)}<core>${core}</core>`);
        });
        lines.push(`</cores></emulator>`);
      };
      return lines;
    }
    valueToTag(system, prop) { return [`<${prop}>${system[prop]}</${prop}>`] }
  }();

  writeDict(dict, options) {
    options.comment ||= 'This file was generated from /opt/batocera-emulationstation/conf.d/es_systems.yml during PKGBUILD';
    options.attributes ||= ['name', 'manufacturer', 'release', 'hardware', 'path', 'extensions', 'command', 'platform', 'theme', 'emulators'];
    if (!options.attributes.includes('key')) options.attributes.unshift('key');
    options.filter ||= () => true;

    //make a working copy because we are going to change it during parsing
    // note: this will delete the `source` info of PropValue 
    dict = JSON.parse(JSON.stringify(dict));
    // recursively go through all value strings and encode them to be compatible to XML
    dict = xmlEncode(dict);

    this.write([
      '<?xml version="1.0"?>',
      `<!-- ${options.comment} -->`,
      '<systemList>\n'
    ]);
    Object.keys(dict).filter(options.filter).forEach(key => {
      let system = dict[key];
      if (typeof system != "object" || Object.keys(system).length == 0) {
        log.warn("Skipping empty system declaration for", key);
        return;
      }
      this.write(this.systemToXml(key, system, options));
    });
    this.write('</systemList>\n');
  }

  systemToXml(key, system, options) {
    //initialize defaults
    system.key = key;
    setDefault(system, "release", 'None');
    setDefault(system, "hardware", 'None');
    setDefault(system, "platform", key);
    setDefault(system, "theme", key);
    setDefault(system, "path", options.romDir + '/' + key);
    setDefault(system, "command", EsSystemsWriter.#DEFAULT_LAUNCH_COMMAND);

    let lines = [];
    options.attributes.forEach(attribute => {
      if (typeof system[attribute] == "undefined") { return }

      let handler = EsSystemsWriter.#ATTRIBUTE_HANDLER[attribute] || EsSystemsWriter.#ATTRIBUTE_HANDLER.valueToTag;
      let handlerResult = handler(system, attribute);
      if (typeof Array.isArray(handlerResult)) lines.push(...handlerResult.map(_ => whitespace(2) + _));
    });
    if (lines.length == 0) { return '' }
    else return [
      whitespace(2) + '<system>',
      ...lines,
      '</system>\n'
    ].join('\n' + whitespace(2));
  }
}

class EsFeaturesWriter extends Writer {
  writeDict(dict, options) {
    options.comment ||= 'This file was generated from /opt/batocera-emulationstation/conf.d/es_features.yml during PKGBUILD';
    options.filter ||= () => true;

    //make a working copy because we are going to change it during parsing
    // note: this will delete the `source` info of PropValue
    dict = JSON.parse(JSON.stringify(dict));
    // recursively go through all value strings and encode them to be compatible to XML
    dict = xmlEncode(dict);

    this.write([
      '<?xml version="1.0"?>',
      `<!-- ${options.comment} -->`,
      '<features>\n',
    ]);

    if (typeof (dict.shared || {}).cfeatures == "object") {
      this.write([
        whitespace(2) + '<sharedFeatures>',
        ...this.createFeatureDefinitionsXml(dict.shared.cfeatures, 4),
        whitespace(2) + '</sharedFeatures>\n'
      ]);
    }
    delete dict.shared;

    if (typeof dict.global != "undefined" && Array.isArray(dict.global.shared)) {
      this.write([
        whitespace(2) + '<globalFeatures>',
        ...this.createSharedLinkXml(dict.global.shared, 4),
        whitespace(2) + '</globalFeatures>\n'
      ]);
    }
    delete dict.global;

    Object.keys(dict).filter(options.filter).forEach(key => {
      let emulator = dict[key];
      this.write(this.createFeatureContainerXml(emulator, 'emulator', key, 2));
      this.write('\n');
    });

    this.write('</features>\n');
  }

  createFeatureContainerXml(data, rootTagName, name, whitespaces = 2) {
    let lines = [];

    let emulatorTag = `${whitespace(whitespaces)}<${rootTagName} name="${name}"`
    if (Array.isArray(data.features)) { emulatorTag += ` features="${data.features.join(', ')}"` }
    lines.push(emulatorTag + '>');

    if (typeof data.systems == "object") {
      lines.push(
        whitespace(whitespaces + 2) + '<systems>',
        ...Object.entries(data.systems).flatMap(entry => {
          return this.createFeatureContainerXml(entry[1], 'system', entry[0], whitespaces + 4)
        }),
        whitespace(whitespaces + 2) + '</systems>'
      );
    }
    if (typeof data.cores == "object") {
      lines.push(
        whitespace(whitespaces + 2) + '<cores>',
        ...Object.entries(data.cores).flatMap(entry => {
          return this.createFeatureContainerXml(entry[1], 'core', entry[0], whitespaces + 4)
        }),
        whitespace(whitespaces + 2) + '</cores>'
      );
    }
    lines.push(...this.createSharedLinkXml(data.shared, whitespaces + 2));
    lines.push(...this.createFeatureDefinitionsXml(data.cfeatures, whitespaces + 2));
    lines.push(`${whitespace(whitespaces)}</${rootTagName}>`);
    return lines;
  }

  createSharedLinkXml(sharedArray = [], whitespaces = 4) {
    return sharedArray.map(_ => `${whitespace(whitespaces)}<sharedFeature value="${_}" />`);
  }

  createFeatureDefinitionsXml(cfeatureDict = {}, whitespaces = 4) {
    let lines = [];
    let realFeatureList = {};
    for (let [key, value] of Object.entries(cfeatureDict)) {
      if (typeof value.template == "undefined") {
        realFeatureList[key] = value;
        continue;
      }
      for (let i = 1; i <= value.repeat; i++) {
        let copy = JSON.stringify(value.template).replace(/{{iteration}}/g, i);
        realFeatureList[key + i] = JSON.parse(copy);
      }
    }
    for (let [key, value] of Object.entries(realFeatureList)) {
      let featureTagAdditions = [];
      Object.keys(value).filter(k => k != 'choices').forEach(k => {
        featureTagAdditions.push(`${k}="${value[k]}"`);
      });
      lines.push(`<feature name="${value.prompt}" value="${key}" ${featureTagAdditions.join(' ')}>`);
      delete value.prompt;

      if (typeof value.preset == "undefined" && typeof value.choices == "object") {
        Object.keys(value.choices).forEach(k => {
          lines.push(`${whitespace(2)}<choice name="${k}" value="${value.choices[k]}" />`);
        });
      }
      lines.push('</feature>');
    }
    return lines.map(_ => whitespace(whitespaces) + _);
  }
}

let FORMATS = {
  REGULAR: ['plain', 'conf', 'sh', 'yml', 'json', 'xml', 'settings'],
  SPECIAL: ['systems', 'features']
};
FORMATS.ALL = [...FORMATS.REGULAR, ...FORMATS.SPECIAL]

module.exports = {
  plain: PlainWriter,
  conf: ConfWriter,
  sh: ShellWriter,
  yml: YamlWriter,
  json: JsonWriter,
  xml: XmlWriter,
  settings: EsSettingsWriter,
  systems: EsSystemsWriter,
  features: EsFeaturesWriter,
  FORMATS,
  xmlEncode
}
