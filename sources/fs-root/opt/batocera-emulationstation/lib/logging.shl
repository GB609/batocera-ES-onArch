# SPDX-FileCopyrightText: 2025 Karsten Teichmann
#
# SPDX-License-Identifier: MIT

# @file
# @brief Generic shell utils for logging
# @description
# The functions declared here will generally write to stderr.
# This allows to capture and process the regular output, e.g. by using `$()`.
# 
# The log functions will not reset exit codes of the executing script to 0.  
# Messages intended to be read by the user will be localized to the user's locale,
# lines going into the log files are forced to LC_ALL=C. 
# This will make reading logs much easier when they are included in issue tickets.

# requires a log file name
[ -n "$1" ] || exit 1

# don't re-init if it was set already
[ -z "$LOGFILE" ] || return 0

LOGFILE="$1"
mkdir -p "$(dirname "$LOGFILE")"

exec 3>"$LOGFILE"

_hasFunc _logOnly || \
function _logOnly {
  local RET="$?"
  echo "$(LC_ALL=C lc "$@")" >&3 \
    || return "$?"
  return "$RET"
}


_hasFunc _outOnly || \
# @description Counter part to _logOnly
# Mostly useful when messages to localize are build with prefixes (and over multiple nested function calls),
# so _logAndOut can't handle the staged translation and mixed translation behavior
function _outOnly {
  local RET="$?"
  echo "$(lc "$@")" >&2 \
    || return "$?"
  return "$RET"
}

_hasFunc _logAndOut || \
function _logAndOut {
  local RET="$?"
  _logOnly "$@" || true
  _outOnly "$@" || true
  return "$RET"
}

_hasFunc _logAndOutWhenDebug || \
function _logAndOutWhenDebug {
  local RET="$?"
  if [ -n "$PRINT_DEBUG" ]; then
    _logAndOut "$@" || true
  else
    _logOnly "$@" || true
  fi
  return "$RET"
}

_hasFunc _pipeDebugLog || \
function _pipeDebugLog {
  if [ -n "$PRINT_DEBUG" ]; then
    tee -a "$LOGFILE" >&2
  else
    cat >&3
  fi
}

_hasFunc _printException || \
# @description
# Print a message, followed by a full stack trace. Trace starts just below `_printException`.
# @arg $1 string Message to print 
# @arg $2 string (optional) print function to use (default: _logAndOut") 
function _printException {
  local _msg="$1"
  local _printer="${2:-_logAndOut}"
  NO_LC=true "$_printer" "$(_callstack "$_msg" 1)"
} 

_hasFunc _callstack || \
# @description Generate a call stack similar to how it is done in higher languages.
# @arg $1 message to print first (optional)
# @arg $2 int number of top level stack entries to skip. Useful when `_callstack` is called directly from within other helpers.
# @stdout generated stack 
function _callstack {
  [ -z "$1" ] || printf '%s\n' "$1"

  local idx="${2:-0}"
  while [ -n "${BASH_LINENO[$idx]}" ]; do 
    local _line="${BASH_LINENO[$idx]}"
    local _file="${BASH_SOURCE[$idx+1]}"
    local _func="${FUNCNAME[$idx+1]:-main}"
    printf '\tat %s (%s:%d)\n' "$_func" "$_file" "$_line"
    # use pre-increment so that let won't return an error code of '0++'
    let ++idx 
  done
}

export -f _outOnly _logOnly _logAndOut _logAndOutWhenDebug _pipeDebugLog _callstack
